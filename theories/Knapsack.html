<!doctype html>
<html class="alectryon-standalone">
  <head>
    <title>Knapsack.v</title>
    <meta charset="utf-8" />
    <meta content="Alectryon" name="generator" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="alectryon.css" rel="stylesheet" />
    <link href="pygments.css" rel="stylesheet" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css"
      integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw=="
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css"
      integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA=="
      crossorigin="anonymous"
    />
    <script src="alectryon.js"></script>
  </head>
  <body>
    <article class="alectryon-root alectryon-centered">
      <div class="alectryon-banner">
        Built with
        <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>,
        running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span
          class="alectryon-bubble"
        ></span
        >) indicate interactive fragments: hover for details, tap to reveal
        contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate,
        <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of
        <kbd>Ctrl</kbd>.
      </div>
      <pre
        class="alectryon-io highlight"
      ><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> numbers list.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssrmatching_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssreflect_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> CoqCP <span class="kn">Require Import</span> Options.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">knapsack</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="mi">0</span>
  | (weight, value) :: tail =&gt;
    <span class="kr">if</span> decide (limit &lt; weight) <span class="kr">then</span> knapsack tail limit
    <span class="kr">else</span> knapsack tail limit `max` (value + knapsack tail (limit - weight))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">knapsack_elements</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : list (nat * nat) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | (weight, value) :: tail =&gt;
    <span class="kr">if</span> decide (limit &lt; weight) <span class="kr">then</span> knapsack_elements tail limit
    <span class="kr">else</span>
      <span class="kr">let</span> <span class="nv">without</span> := knapsack_elements tail limit <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">with_item</span> := (weight, value) :: knapsack_elements tail (limit - weight) <span class="kr">in</span>
      <span class="kr">if</span> decide ((fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> without) &lt; (fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> with_item))
      <span class="kr">then</span> with_item
      <span class="kr">else</span> without
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1"><span class="kn">Lemma</span> <span class="nf">knapsackElementsSublist</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : sublist (knapsack_elements l limit) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements l limit `sublist_of` l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements l limit `sublist_of` l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3"><span class="nb">revert</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat, knapsack_elements l _0 `sublist_of` l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat, knapsack_elements [] _0 `sublist_of` []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk5"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements (head :: tail) _0
  `sublist_of` head :: tail</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat, knapsack_elements [] _0 `sublist_of` []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements (head :: tail) _0
  `sublist_of` head :: tail</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">let</span> (<span class="nv">_1</span>, _2) := head <span class="kr">in</span>
   <span class="kr">if</span> decide (_0 &lt; _1)
   <span class="kr">then</span> knapsack_elements tail _0
   <span class="kr">else</span>
    <span class="kr">if</span>
     decide
       (foldr
          (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4) <span class="mi">0</span>
          (knapsack_elements tail _0) &lt;
        _2 +
        foldr
          (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4) <span class="mi">0</span>
          (knapsack_elements tail (_0 - _1)))
    <span class="kr">then</span> (_1, _2) :: knapsack_elements tail (_0 - _1)
    <span class="kr">else</span> knapsack_elements tail _0)
  `sublist_of` head :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk9"><span class="nb">intro</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span>
 <span class="kr">if</span> decide (limit &lt; _0)
 <span class="kr">then</span> knapsack_elements tail limit
 <span class="kr">else</span>
  <span class="kr">if</span>
   decide
     (foldr (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
        <span class="mi">0</span> (knapsack_elements tail limit) &lt;
      _1 +
      foldr (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
        <span class="mi">0</span> (knapsack_elements tail (limit - _0)))
  <span class="kr">then</span> (_0, _1) :: knapsack_elements tail (limit - _0)
  <span class="kr">else</span> knapsack_elements tail limit)
`sublist_of` head :: tail</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chka"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span>
 <span class="kr">if</span> decide (limit &lt; _0)
 <span class="kr">then</span> knapsack_elements tail limit
 <span class="kr">else</span>
  <span class="kr">if</span>
   decide
     (foldr (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
        <span class="mi">0</span> (knapsack_elements tail limit) &lt;
      _1 +
      foldr (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
        <span class="mi">0</span> (knapsack_elements tail (limit - _0)))
  <span class="kr">then</span> (_0, _1) :: knapsack_elements tail (limit - _0)
  <span class="kr">else</span> knapsack_elements tail limit)
`sublist_of` head :: tail</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chkb"><span class="nb">destruct</span> head <span class="kr">as</span> [weight value].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (limit &lt; weight)
 <span class="kr">then</span> knapsack_elements tail limit
 <span class="kr">else</span>
  <span class="kr">if</span>
   decide
     (foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
        <span class="mi">0</span> (knapsack_elements tail limit) &lt;
      value +
      foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
        <span class="mi">0</span> (knapsack_elements tail (limit - weight)))
  <span class="kr">then</span>
   (weight, value)
   :: knapsack_elements tail (limit - weight)
  <span class="kr">else</span> knapsack_elements tail limit)
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chkc">case_decide <span class="kr">as</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail limit
`sublist_of` (weight, value) :: tail</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chkd"><hr></label><div class="goal-conclusion">(<span class="kr">if</span>
  decide
    (foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
       <span class="mi">0</span> (knapsack_elements tail limit) &lt;
     value +
     foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
       <span class="mi">0</span> (knapsack_elements tail (limit - weight)))
 <span class="kr">then</span>
  (weight, value)
  :: knapsack_elements tail (limit - weight)
 <span class="kr">else</span> knapsack_elements tail limit)
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail limit
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chkf"><span class="nb">apply</span> sublist_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail limit `sublist_of` tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span>
  decide
    (foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
       <span class="mi">0</span> (knapsack_elements tail limit) &lt;
     value +
     foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
       <span class="mi">0</span> (knapsack_elements tail (limit - weight)))
 <span class="kr">then</span>
  (weight, value)
  :: knapsack_elements tail (limit - weight)
 <span class="kr">else</span> knapsack_elements tail limit)
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk11">case_decide <span class="kr">as</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(weight, value)
:: knapsack_elements tail (limit - weight)
`sublist_of` (weight, value) :: tail</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk12"><hr></label><div class="goal-conclusion">knapsack_elements tail limit
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk13">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(weight, value)
:: knapsack_elements tail (limit - weight)
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk14"><span class="nb">apply</span> sublist_skip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail (limit - weight)
`sublist_of` tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk15">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail limit
`sublist_of` (weight, value) :: tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk16"><span class="nb">apply</span> sublist_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  knapsack_elements tail _0 `sublist_of` tail</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements tail limit `sublist_of` tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk17"><span class="kn">Lemma</span> <span class="nf">foldrSum9</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">a</span> <span class="nv">b</span> : nat) : fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> ((a, b) :: l) = b + fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  ((a, b) :: l) =
b +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  ((a, b) :: l) =
b +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk19"><span class="nb">unfold</span> foldr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b).<span class="mi">2</span> +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">2</span> + _0 _3
   <span class="kr">end</span>) l =
b +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">2</span> + _0 _3
   <span class="kr">end</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">2</span> + _0 _3
   <span class="kr">end</span>) l =
b +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">2</span> + _0 _3
   <span class="kr">end</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1b"><span class="kn">Lemma</span> <span class="nf">foldrSum11</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">a</span> <span class="nv">b</span> : nat) : fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; fst x + acc) <span class="mi">0</span> ((a, b) :: l) = a + fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; fst x + acc) <span class="mi">0</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  ((a, b) :: l) =
a +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  ((a, b) :: l) =
a +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1d"><span class="nb">unfold</span> foldr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b).<span class="mi">1</span> +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">1</span> + _0 _3
   <span class="kr">end</span>) l =
a +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">1</span> + _0 _3
   <span class="kr">end</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">1</span> + _0 _3
   <span class="kr">end</span>) l =
a +
(<span class="kr">fix</span> _0 (_1 : list (nat * nat)) : nat :=
   <span class="kr">match</span> _1 <span class="kr">with</span>
   | [] =&gt; <span class="mi">0</span>
   | _2 :: _3 =&gt; _2.<span class="mi">1</span> + _0 _3
   <span class="kr">end</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk1f"><span class="kn">Lemma</span> <span class="nf">knapsackElementsSum</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> (knapsack_elements l limit) = knapsack l limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements l limit) = knapsack l limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements l limit) = 
knapsack l limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk21"><span class="nb">revert</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements l _0) = 
  knapsack l _0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk22"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements [] _0) = 
  knapsack [] _0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk23"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements (head :: tail) _0) =
  knapsack (head :: tail) _0</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk24">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements [] _0) = 
  knapsack [] _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements (head :: tail) _0) =
  knapsack (head :: tail) _0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk26"><span class="nb">destruct</span> head <span class="kr">as</span> [weight value].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements ((weight, value) :: tail) _0) =
  knapsack ((weight, value) :: tail) _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk27"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (<span class="kr">if</span> decide (_0 &lt; weight)
     <span class="kr">then</span> knapsack_elements tail _0
     <span class="kr">else</span>
      <span class="kr">if</span>
       decide
         (foldr
            (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
            <span class="mi">0</span> (knapsack_elements tail _0) &lt;
          value +
          foldr
            (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
            <span class="mi">0</span> (knapsack_elements tail (_0 - weight)))
      <span class="kr">then</span>
       (weight, value)
       :: knapsack_elements tail (_0 - weight)
      <span class="kr">else</span> knapsack_elements tail _0) =
  (<span class="kr">if</span> decide (_0 &lt; weight)
   <span class="kr">then</span> knapsack tail _0
   <span class="kr">else</span>
    knapsack tail _0
    `max` (value + knapsack tail (_0 - weight)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk28"><span class="nb">intro</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span> decide (limit &lt; weight)
   <span class="kr">then</span> knapsack_elements tail limit
   <span class="kr">else</span>
    <span class="kr">if</span>
     decide
       (foldr
          (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
          (knapsack_elements tail limit) &lt;
        value +
        foldr
          (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
          (knapsack_elements tail (limit - weight)))
    <span class="kr">then</span>
     (weight, value)
     :: knapsack_elements tail (limit - weight)
    <span class="kr">else</span> knapsack_elements tail limit) =
(<span class="kr">if</span> decide (limit &lt; weight)
 <span class="kr">then</span> knapsack tail limit
 <span class="kr">else</span>
  knapsack tail limit
  `max` (value + knapsack tail (limit - weight)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk29">case_decide <span class="kr">as</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) = 
knapsack tail limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk2a"><hr></label><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span>
    decide
      (foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail limit) &lt;
       value +
       foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail (limit - weight)))
   <span class="kr">then</span>
    (weight, value)
    :: knapsack_elements tail (limit - weight)
   <span class="kr">else</span> knapsack_elements tail limit) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) = 
knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span>
    decide
      (foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail limit) &lt;
       value +
       foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail (limit - weight)))
   <span class="kr">then</span>
    (weight, value)
    :: knapsack_elements tail (limit - weight)
   <span class="kr">else</span> knapsack_elements tail limit) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk2d">case_decide <span class="kr">as</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  ((weight, value)
   :: knapsack_elements tail (limit - weight)) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk2e"><hr></label><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk2f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  ((weight, value)
   :: knapsack_elements tail (limit - weight)) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk30"><span class="nb">rewrite</span> !IH <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>knapsack tail limit &lt;
value + knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  ((weight, value)
   :: knapsack_elements tail (limit - weight)) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk31"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : knapsack tail limit `max` (value + knapsack tail (limit - weight)) = value + knapsack tail (limit - weight)), foldrSum9, IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>knapsack tail limit &lt;
value + knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value + knapsack tail (limit - weight) =
value + knapsack tail (limit - weight)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk32">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk33"><span class="nb">rewrite</span> !IH <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ knapsack tail limit &lt;
  value + knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) =
knapsack tail limit
`max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk34"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : knapsack tail limit `max` (value + knapsack tail (limit - weight)) = knapsack tail limit), IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) =
  knapsack tail _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ knapsack tail limit &lt;
  value + knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack tail limit = knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk35"><span class="kn">Lemma</span> <span class="nf">knapsackElementsLimit</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; fst x + acc) <span class="mi">0</span> (knapsack_elements l limit) &lt;= limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements l limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements l limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk37"><span class="nb">revert</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements l _0) â‰¤ _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk38"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements [] _0) â‰¤ _0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk39"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements (head :: tail) _0) â‰¤ _0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements [] _0) â‰¤ _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat, <span class="mi">0</span> â‰¤ _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements (head :: tail) _0) â‰¤ _0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3d"><span class="nb">intro</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements (head :: tail) limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3e"><span class="nb">destruct</span> head <span class="kr">as</span> [weight value].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements ((weight, value) :: tail) limit)
â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk3f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span> decide (limit &lt; weight)
   <span class="kr">then</span> knapsack_elements tail limit
   <span class="kr">else</span>
    <span class="kr">if</span>
     decide
       (foldr
          (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
          (knapsack_elements tail limit) &lt;
        value +
        foldr
          (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
          (knapsack_elements tail (limit - weight)))
    <span class="kr">then</span>
     (weight, value)
     :: knapsack_elements tail (limit - weight)
    <span class="kr">else</span> knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk40">case_decide <span class="kr">as</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) â‰¤ limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk41"><hr></label><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span>
    decide
      (foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail limit) &lt;
       value +
       foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail (limit - weight)))
   <span class="kr">then</span>
    (weight, value)
    :: knapsack_elements tail (limit - weight)
   <span class="kr">else</span> knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk42">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk43">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (<span class="kr">if</span>
    decide
      (foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail limit) &lt;
       value +
       foldr
         (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
         (knapsack_elements tail (limit - weight)))
   <span class="kr">then</span>
    (weight, value)
    :: knapsack_elements tail (limit - weight)
   <span class="kr">else</span> knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk44">case_decide <span class="kr">as</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  ((weight, value)
   :: knapsack_elements tail (limit - weight)) â‰¤ limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk45"><hr></label><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk46">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  ((weight, value)
   :: knapsack_elements tail (limit - weight)) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk47"><span class="nb">rewrite</span> foldrSum11.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail (limit - weight)) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk48"><span class="nb">pose proof</span> IH (limit - weight).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) &lt;
value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail (limit - weight))
â‰¤ limit - weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail (limit - weight)) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk49">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4a"><span class="nb">pose proof</span> IH limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2) <span class="mi">0</span>
    (knapsack_elements tail _0) â‰¤ _0</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>Â¬ foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail limit) &lt;
  value +
  foldr
    (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements tail (limit - weight))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> (knapsack_elements tail limit) â‰¤ limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
  (knapsack_elements tail limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isMaximum</span> (<span class="nv">x</span> : nat) (<span class="nv">predicate</span> : nat -&gt; <span class="kt">Prop</span>) := predicate x /\ <span class="kr">âˆ€</span> <span class="nv">y</span>, predicate y â†’ y â‰¤ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4b"><span class="kn">Lemma</span> <span class="nf">knapsackMax</span> (<span class="nv">l</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : isMaximum (knapsack l limit) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">exists</span> <span class="nv">choice</span>, sublist choice l /\ fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; snd x + acc) <span class="mi">0</span> choice = x /\ fold_right (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">acc</span> =&gt; fst x + acc) <span class="mi">0</span> choice &lt;= limit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isMaximum (knapsack l limit)
  (<span class="kr">Î»</span> <span class="nv">_0</span> : nat,
     <span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
       _1 `sublist_of` l
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
           <span class="mi">0</span> _1 = _0
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
             <span class="mi">0</span> _1 â‰¤ limit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isMaximum (knapsack l limit)
  (<span class="kr">Î»</span> <span class="nv">_0</span> : nat,
     <span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
       _1 `sublist_of` l
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
           <span class="mi">0</span> _1 = _0
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
             <span class="mi">0</span> _1 â‰¤ limit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4d"><span class="nb">revert</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack l _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` l
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4)
             <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk4e"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack [] _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` []
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4)
             <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk4f"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack (head :: tail) _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` head :: tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4)
             <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk50">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack [] _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` []
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4)
             <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk51"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isMaximum (knapsack [] a)
  (<span class="kr">Î»</span> <span class="nv">_0</span> : nat,
     <span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
       _1 `sublist_of` []
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
           <span class="mi">0</span> _1 = _0
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
             <span class="mi">0</span> _1 â‰¤ a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk52"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` []
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = knapsack [] a
    âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk53"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` []
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3) <span class="mi">0</span>
         _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
           <span class="mi">0</span> _1 â‰¤ a) â†’ _0 â‰¤ knapsack [] a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` []
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = knapsack [] a
    âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk55"><span class="kr">exists</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] `sublist_of` []
âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    [] = knapsack [] a
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
      [] â‰¤ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk56"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] `sublist_of` [] âˆ§ <span class="mi">0</span> = <span class="mi">0</span> âˆ§ <span class="mi">0</span> â‰¤ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk57"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] `sublist_of` []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk58"><hr></label><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span> âˆ§ <span class="mi">0</span> â‰¤ a</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk59">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] `sublist_of` []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span> âˆ§ <span class="mi">0</span> â‰¤ a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` []
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3) <span class="mi">0</span>
         _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
           <span class="mi">0</span> _1 â‰¤ a) â†’ _0 â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5c"><span class="nb">intros</span> b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` []
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = b
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5d"><span class="nb">destruct</span> c <span class="kr">as</span> [choice [h1 [h2 h3]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice `sublist_of` []</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> choice = b</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5e"><span class="nb">rewrite</span> sublist_nil_r <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice = []</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> choice = b</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk5f"><span class="nb">rewrite</span> h1 <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice = []</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> [] = b</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk60"><span class="nb">simpl</span> <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice = []</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = b</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk61"><span class="nb">subst</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice = []</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> â‰¤ knapsack [] a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk62"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>choice</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>choice = []</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> choice â‰¤ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> â‰¤ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk63">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack (head :: tail) _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` head :: tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat), _3.<span class="mi">2</span> + _4)
             <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk64"><span class="nb">intro</span> limit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isMaximum (knapsack (head :: tail) limit)
  (<span class="kr">Î»</span> <span class="nv">_0</span> : nat,
     <span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
       _1 `sublist_of` head :: tail
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3)
           <span class="mi">0</span> _1 = _0
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
             <span class="mi">0</span> _1 â‰¤ limit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk65"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` head :: tail
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = knapsack (head :: tail) limit
    âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk66"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` head :: tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3) <span class="mi">0</span>
         _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
           <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack (head :: tail) limit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` head :: tail
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = knapsack (head :: tail) limit
    âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk68"><span class="kr">exists</span> (<span class="nv">knapsack_elements</span> (head :: tail) limit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">knapsack_elements (head :: tail) limit
`sublist_of` head :: tail
âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span>
    (knapsack_elements (head :: tail) limit) =
  knapsack (head :: tail) limit
  âˆ§ foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span>
      (knapsack_elements (head :: tail) limit) â‰¤ limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; [| <span class="nb">constructor</span>]; [<span class="nb">apply</span> knapsackElementsSublist | <span class="nb">apply</span> knapsackElementsSum | <span class="nb">apply</span> knapsackElementsLimit].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` head :: tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">2</span> + _3) <span class="mi">0</span>
         _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat), _2.<span class="mi">1</span> + _3)
           <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack (head :: tail) limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6a"><span class="nb">intros</span> score h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` head :: tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2) <span class="mi">0</span>
      _0 = score
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack (head :: tail) limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6b"><span class="nb">destruct</span> h <span class="kr">as</span> [l1 [hl [hs hS]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>(nat * nat)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` head :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack (head :: tail) limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6c"><span class="nb">destruct</span> head <span class="kr">as</span> [weight value].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack ((weight, value) :: tail) limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ (<span class="kr">if</span> decide (limit &lt; weight)
   <span class="kr">then</span> knapsack tail limit
   <span class="kr">else</span>
    knapsack tail limit
    `max` (value + knapsack tail (limit - weight)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk6e">case_decide <span class="kr">as</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk6f"><hr></label><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk70">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk71"><span class="nb">pose proof</span> IH limit <span class="kr">as</span> [aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk72"><span class="nb">rewrite</span> sublist_cons_r <span class="kr">in</span> hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail
âˆ¨ <span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
    l1 = (weight, value) :: _0
    âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk73"><span class="nb">destruct</span> hl <span class="kr">as</span> [hl | hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  l1 = (weight, value) :: _0
  âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk74"><hr></label><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk75">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (bb score (ex_intro _ l1 (conj hl (conj hs hS)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk76">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  l1 = (weight, value) :: _0
  âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk77"><span class="nb">destruct</span> hl <span class="kr">as</span> [l2 [hl hL]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l2</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l2 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk78"><span class="nb">rewrite</span> hl, foldrSum11 <span class="kr">in</span> hS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l2</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l2 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l2 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score â‰¤ knapsack tail limit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk79">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` (weight, value) :: tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7a"><span class="nb">rewrite</span> sublist_cons_r <span class="kr">in</span> hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail
âˆ¨ <span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
    l1 = (weight, value) :: _0
    âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7b"><span class="nb">destruct</span> hl <span class="kr">as</span> [hl | hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  l1 = (weight, value) :: _0
  âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk7c"><hr></label><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7e"><span class="nb">pose proof</span> IH limit <span class="kr">as</span> [aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk7f"><span class="nb">pose proof</span> bb score (ex_intro _ l1 (conj hl (conj hs hS))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail limit
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ limit)
  â†’ _0 â‰¤ knapsack tail limit</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score â‰¤ knapsack tail limit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk80">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  l1 = (weight, value) :: _0
  âˆ§ _0 `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk81"><span class="nb">destruct</span> hl <span class="kr">as</span> [l [hl hL]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk82"><span class="nb">pose proof</span> IH (limit - weight) <span class="kr">as</span> [aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l1 = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk83"><span class="nb">rewrite</span> hl, foldrSum9 <span class="kr">in</span> hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l1 â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk84"><span class="nb">rewrite</span> hl, foldrSum11 <span class="kr">in</span> hS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk85"><span class="nb">epose proof</span> bb (score - value) (ex_intro _ l (conj hL (conj _ _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score - value â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
â‰¤ knapsack tail limit
  `max` (value + knapsack tail (limit - weight))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk86"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span> l =
score - value</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Knapsack-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><label class="goal-separator" for="Knapsack-v-chk87"><hr></label><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span> l
â‰¤ limit - weight</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk88">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1) <span class="mi">0</span> l =
score - value</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk89">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span> l
â‰¤ limit - weight</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Knapsack-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="Knapsack-v-chk8a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>weight, value</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  isMaximum (knapsack tail _0)
    (<span class="kr">Î»</span> <span class="nv">_1</span> : nat,
       <span class="kr">âˆƒ</span> <span class="nv">_2</span> : list (nat * nat),
         _2 `sublist_of` tail
         âˆ§ foldr
             (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                _3.<span class="mi">2</span> + _4) <span class="mi">0</span> _2 = _1
           âˆ§ foldr
               (<span class="kr">Î»</span> (<span class="nv">_3</span> : nat * nat) (<span class="nv">_4</span> : nat),
                  _3.<span class="mi">1</span> + _4) <span class="mi">0</span> _2 â‰¤ _0)</span></span></span><br><span><var>limit, score</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l1 = (weight, value) :: l</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l `sublist_of` tail</span></span></span><br><span><var>hs</var><span class="hyp-type"><b>: </b><span>value +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">2</span> + _1)
  <span class="mi">0</span> l = score</span></span></span><br><span><var>hS</var><span class="hyp-type"><b>: </b><span>weight +
foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1)
  <span class="mi">0</span> l â‰¤ limit</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Â¬ limit &lt; weight</span></span></span><br><span><var>aa</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">_0</span> : list (nat * nat),
  _0 `sublist_of` tail
  âˆ§ foldr
      (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">2</span> + _2)
      <span class="mi">0</span> _0 = knapsack tail (limit - weight)
    âˆ§ foldr
        (<span class="kr">Î»</span> (<span class="nv">_1</span> : nat * nat) (<span class="nv">_2</span> : nat), _1.<span class="mi">1</span> + _2)
        <span class="mi">0</span> _0 â‰¤ limit - weight</span></span></span><br><span><var>bb</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">_0</span> : nat,
  (<span class="kr">âˆƒ</span> <span class="nv">_1</span> : list (nat * nat),
     _1 `sublist_of` tail
     âˆ§ foldr
         (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
            _2.<span class="mi">2</span> + _3) <span class="mi">0</span> _1 = _0
       âˆ§ foldr
           (<span class="kr">Î»</span> (<span class="nv">_2</span> : nat * nat) (<span class="nv">_3</span> : nat),
              _2.<span class="mi">1</span> + _3) <span class="mi">0</span> _1 â‰¤ 
         limit - weight)
  â†’ _0 â‰¤ knapsack tail (limit - weight)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr (<span class="kr">Î»</span> (<span class="nv">_0</span> : nat * nat) (<span class="nv">_1</span> : nat), _0.<span class="mi">1</span> + _1) <span class="mi">0</span> l
â‰¤ limit - weight</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre>
    </article>
  </body>
</html>
