<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>DisjointSetUnion.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk0"><span class="kn">From</span> CoqCP <span class="kn">Require Import</span> Options ListsEqual.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssrmatching_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssreflect_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> numbers list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Wellfounded.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Tree</span> :=
| Unit
| Unite (a b : Tree).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">encodeToList</span> (<span class="nv">x</span> : Tree) : list bool :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; [true]
  | Unite a b =&gt; encodeToList b ++ encodeToList a ++ [false]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">listToNat</span> (<span class="nv">x</span> : list bool) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | [] =&gt; <span class="mi">0</span>
  | false :: rest =&gt; <span class="mi">2</span> * listToNat rest
  | true :: rest =&gt; <span class="mi">2</span> * listToNat rest + <span class="mi">1</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">encodeToNat</span> (<span class="nv">x</span> : Tree) := listToNat (encodeToList x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1"><span class="kn">Lemma</span> <span class="nf">encodeToListFirstTrue</span> (<span class="nv">x</span> : Tree) : <span class="kr">exists</span> <span class="nv">s</span>, encodeToList x = true :: s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool, encodeToList x = true :: _0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool, encodeToList x = true :: _0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3"><span class="nb">induction</span> x <span class="kr">as</span> [| a [s1 IHa] b [s2 IHb]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool, encodeToList Unit = true :: _0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s2</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool,
  encodeToList (Unite a b) = true :: _0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool, encodeToList Unit = true :: _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6"><span class="kr">exists</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToList Unit = [true]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : list bool,
  encodeToList (Unite a b) = true :: _0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8"><span class="kr">exists</span> (<span class="nv">s2</span> ++ true :: s1 ++ [false]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToList (Unite a b) =
true :: s2 ++ true :: s1 ++ [false]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToList b ++ encodeToList a ++ [false] =
true :: s2 ++ true :: s1 ++ [false]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka"><span class="nb">rewrite</span> IHa, IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(true :: s2) ++ (true :: s1) ++ [false] =
true :: s2 ++ true :: s1 ++ [false]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">listsEqual.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb"><span class="kn">Lemma</span> <span class="nf">zeroLtEncodeToNat</span> (<span class="nv">x</span> : Tree) : <span class="mi">0</span> &lt; encodeToNat x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd"><span class="nb">pose proof</span> encodeToListFirstTrue x <span class="kr">as</span> [s h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToList x = true :: s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToList x = true :: s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (encodeToList x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf"><span class="nb">rewrite</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToList x = true :: s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (true :: s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk10"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToList x = true :: s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat s + (listToNat s + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11"><span class="kn">Lemma</span> <span class="nf">listToNatFalse</span> (<span class="nv">x</span> : list bool) : listToNat (x ++ [false]) = listToNat x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [false]) = listToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [false]) = listToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [false]) = listToNat []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [false]) = listToNat tail</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk14"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ [false]) =
listToNat (head :: tail)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [false]) = listToNat []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [false]) = listToNat tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ [false]) =
listToNat (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18"><span class="kn">Lemma</span> <span class="nf">listToNatTrue</span> (<span class="nv">x</span> : list bool) : listToNat (x ++ [true]) &gt; listToNat x + listToNat x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &gt; listToNat x + listToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &gt; listToNat x + listToNat x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [true]) &gt; listToNat [] + listToNat []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [true]) &gt;
listToNat tail + listToNat tail</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1b"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ [true]) &gt;
listToNat (head :: tail) + listToNat (head :: tail)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [true]) &gt; listToNat [] + listToNat []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [true]) &gt;
listToNat tail + listToNat tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ [true]) &gt;
listToNat (head :: tail) + listToNat (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f"><span class="kn">Lemma</span> <span class="nf">listToNatFalseTrue</span> (<span class="nv">x</span> : list bool) : listToNat ((x ++ [false]) ++ [true]) &gt; listToNat x + listToNat x + <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((x ++ [false]) ++ [true]) &gt;
listToNat x + listToNat x + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((x ++ [false]) ++ [true]) &gt;
listToNat x + listToNat x + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (([] ++ [false]) ++ [true]) &gt;
listToNat [] + listToNat [] + <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat ((tail ++ [false]) ++ [true]) &gt;
listToNat tail + listToNat tail + <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk22"><hr></label><div class="goal-conclusion">listToNat (((head :: tail) ++ [false]) ++ [true]) &gt;
listToNat (head :: tail) + listToNat (head :: tail) +
<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (([] ++ [false]) ++ [true]) &gt;
listToNat [] + listToNat [] + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> &gt; <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat ((tail ++ [false]) ++ [true]) &gt;
listToNat tail + listToNat tail + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (((head :: tail) ++ [false]) ++ [true]) &gt;
listToNat (head :: tail) + listToNat (head :: tail) +
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26"><span class="kn">Lemma</span> <span class="nf">listToNatAppLt</span> (<span class="nv">x</span> <span class="nv">a</span> <span class="nv">b</span> : list bool) (<span class="nv">h</span> : listToNat a &lt; listToNat b) : listToNat (x ++ a) &lt; listToNat (x ++ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ a) &lt; listToNat (x ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ a) &lt; listToNat (x ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ a) &lt; listToNat ([] ++ b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ a) &lt; listToNat (tail ++ b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk29"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ a) &lt;
listToNat ((head :: tail) ++ b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ a) &lt; listToNat ([] ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ a) &lt; listToNat (tail ++ b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ a) &lt;
listToNat ((head :: tail) ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c"><span class="kn">Lemma</span> <span class="nf">listToNatAppLeq</span> (<span class="nv">x</span> <span class="nv">a</span> <span class="nv">b</span> : list bool) (<span class="nv">h</span> : listToNat a &lt;= listToNat b) : listToNat (x ++ a) &lt;= listToNat (x ++ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ a) ‚â§ listToNat (x ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ a) ‚â§ listToNat (x ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ a) ‚â§ listToNat ([] ++ b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ a) ‚â§ listToNat (tail ++ b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2f"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ a)
‚â§ listToNat ((head :: tail) ++ b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ a) ‚â§ listToNat ([] ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ a) ‚â§ listToNat (tail ++ b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ a)
‚â§ listToNat ((head :: tail) ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk32"><span class="kn">Lemma</span> <span class="nf">listToNatTruePowerOfTwo</span> (<span class="nv">x</span> : list bool) : listToNat (x ++ [true]) = listToNat x + <span class="mi">2</span>^(length x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) = listToNat x + <span class="mi">2</span> ^ length x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) = listToNat x + <span class="mi">2</span> ^ length x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [true]) =
listToNat [] + <span class="mi">2</span> ^ length []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [true]) =
listToNat tail + <span class="mi">2</span> ^ length tail</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk35"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ [true]) =
listToNat (head :: tail) + <span class="mi">2</span> ^ length (head :: tail)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ [true]) =
listToNat [] + <span class="mi">2</span> ^ length []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ [true]) =
listToNat tail + <span class="mi">2</span> ^ length tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ [true]) =
listToNat (head :: tail) + <span class="mi">2</span> ^ length (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39"><span class="kn">Lemma</span> <span class="nf">listToNatAppLt&#39;</span> (<span class="nv">x</span> <span class="nv">a</span> <span class="nv">b</span> : list bool) (<span class="nv">h</span> : listToNat a &lt; listToNat b) (<span class="nv">hLength</span> : length a = length b) : listToNat (a ++ x) &lt; listToNat (b ++ x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ x) &lt; listToNat (b ++ x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ x) &lt; listToNat (b ++ x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH] <span class="nb">using</span> rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ []) &lt; listToNat (b ++ [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3c"><hr></label><div class="goal-conclusion">listToNat (a ++ tail ++ [head]) &lt;
listToNat (b ++ tail ++ [head])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ []) &lt; listToNat (b ++ [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> !app_nil_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail ++ [head]) &lt;
listToNat (b ++ tail ++ [head])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f"><span class="nb">destruct</span> head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail ++ [true]) &lt;
listToNat (b ++ tail ++ [true])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk40"><hr></label><div class="goal-conclusion">listToNat (a ++ tail ++ [false]) &lt;
listToNat (b ++ tail ++ [false])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk41">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail ++ [true]) &lt;
listToNat (b ++ tail ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42"><span class="nb">clear</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail ++ [true]) &lt;
listToNat (b ++ tail ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43"><span class="nb">rewrite</span> !app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((a ++ tail) ++ [true]) &lt;
listToNat ((b ++ tail) ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44"><span class="nb">remember</span> (a ++ tail) <span class="kr">as</span> x <span class="nb">eqn</span>:hX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &lt;
listToNat ((b ++ tail) ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45"><span class="nb">remember</span> (b ++ tail) <span class="kr">as</span> y <span class="nb">eqn</span>:hY.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &lt; listToNat (y ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46"><span class="nb">assert</span> (hLength2 : length x = length y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length x = length y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk47"><hr></label><div class="goal-conclusion">listToNat (x ++ [true]) &lt; listToNat (y ++ [true])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length x = length y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (a ++ tail) = length y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a"><span class="nb">subst</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (a ++ tail) = length (b ++ tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b"><span class="nb">rewrite</span> !app_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length a + length tail = length b + length tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>x = a ++ tail</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hY</var><span class="hyp-type"><b>: </b><span>y = b ++ tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &lt; listToNat (y ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4d"><span class="nb">clear</span> hLength hX hY a b tail.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &lt; listToNat (y ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4e"><span class="nb">rename</span> IH <span class="nb">into</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (x ++ [true]) &lt; listToNat (y ++ [true])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4f"><span class="nb">rewrite</span> !listToNatTruePowerOfTwo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat x + <span class="mi">2</span> ^ length x &lt;
listToNat y + <span class="mi">2</span> ^ length y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk50"><span class="nb">rewrite</span> hLength2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat x &lt; listToNat y</span></span></span><br><span><var>hLength2</var><span class="hyp-type"><b>: </b><span>length x = length y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat x + <span class="mi">2</span> ^ length y &lt;
listToNat y + <span class="mi">2</span> ^ length y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk51">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail ++ [false]) &lt;
listToNat (b ++ tail ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk52"><span class="nb">rewrite</span> !app_assoc, !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a &lt; listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (a ++ tail) &lt; listToNat (b ++ tail)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ tail) &lt; listToNat (b ++ tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk53"><span class="kn">Lemma</span> <span class="nf">listToNatAppend</span> (<span class="nv">a</span> <span class="nv">b</span> : list bool) : listToNat (a ++ b) = <span class="mi">2</span>^(length a) * listToNat b + listToNat a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ b) =
<span class="mi">2</span> ^ length a * listToNat b + listToNat a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ b) =
<span class="mi">2</span> ^ length a * listToNat b + listToNat a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk55"><span class="nb">induction</span> a <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ b) =
<span class="mi">2</span> ^ length [] * listToNat b + listToNat []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ b) =
<span class="mi">2</span> ^ length tail * listToNat b + listToNat tail</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk56"><hr></label><div class="goal-conclusion">listToNat ((head :: tail) ++ b) =
<span class="mi">2</span> ^ length (head :: tail) * listToNat b +
listToNat (head :: tail)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ([] ++ b) =
<span class="mi">2</span> ^ length [] * listToNat b + listToNat []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk58"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat b = listToNat b + <span class="mi">0</span> + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat (tail ++ b) =
<span class="mi">2</span> ^ length tail * listToNat b + listToNat tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat ((head :: tail) ++ b) =
<span class="mi">2</span> ^ length (head :: tail) * listToNat b +
listToNat (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5a"><span class="kn">Lemma</span> <span class="nf">zeroLtPowerOfTwo</span> (<span class="nv">x</span> : nat) : <span class="mi">0</span> &lt; <span class="mi">2</span>^x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5c"><span class="nb">induction</span> x <span class="kr">as</span> [| x IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk5d"><hr></label><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ S x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk5f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ S x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk61"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; <span class="mi">2</span> ^ x + (<span class="mi">2</span> ^ x + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk62"><span class="kn">Lemma</span> <span class="nf">listToNatAppLeq&#39;</span> (<span class="nv">x</span> <span class="nv">a</span> <span class="nv">b</span> : list bool) (<span class="nv">h</span> : listToNat a &lt;= listToNat b) (<span class="nv">hLength</span> : length a = length b) : listToNat (a ++ x) &lt;= listToNat (b ++ x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ x) ‚â§ listToNat (b ++ x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (a ++ x) ‚â§ listToNat (b ++ x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk64"><span class="nb">rewrite</span> !listToNatAppend.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length a * listToNat x + listToNat a
‚â§ <span class="mi">2</span> ^ length b * listToNat x + listToNat b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk65"><span class="nb">rewrite</span> hLength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a, b</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat b</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length a = length b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length b * listToNat x + listToNat a
‚â§ <span class="mi">2</span> ^ length b * listToNat x + listToNat b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk66"><span class="kn">Lemma</span> <span class="nf">listToNatAppFirst</span> (<span class="nv">x</span> <span class="nv">a</span> : list bool) : listToNat a &lt;= listToNat (x ++ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat a ‚â§ listToNat (x ++ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat a ‚â§ listToNat (x ++ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk68"><span class="nb">induction</span> x <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat a ‚â§ listToNat ([] ++ a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat (tail ++ a)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk69"><hr></label><div class="goal-conclusion">listToNat a ‚â§ listToNat ((head :: tail) ++ a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat a ‚â§ listToNat ([] ++ a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>tail, a</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>listToNat a ‚â§ listToNat (tail ++ a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat a ‚â§ listToNat ((head :: tail) ++ a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> head; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6c"><span class="kn">Lemma</span> <span class="nf">encodeToNatSubtermLt1</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Tree) (<span class="nv">h</span> : encodeToNat a &lt; encodeToNat c) : encodeToNat (Unite a b) &lt; encodeToNat (Unite c b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) &lt; encodeToNat (Unite c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) &lt; encodeToNat (Unite c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6e"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite a b)) &lt;
listToNat (encodeToList (Unite c b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk6f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList b ++ encodeToList a ++ [false]) &lt;
listToNat
  (encodeToList b ++ encodeToList c ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk70"><span class="nb">rewrite</span> !app_assoc, !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a) &lt;
listToNat (encodeToList b ++ encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk71"><span class="nb">apply</span> listToNatAppLt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList a) &lt;
listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk72"><span class="kn">Lemma</span> <span class="nf">encodeToNatSubtermLeq1</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Tree) (<span class="nv">h</span> : encodeToNat a &lt;= encodeToNat c) : encodeToNat (Unite a b) &lt;= encodeToNat (Unite c b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) ‚â§ encodeToNat (Unite c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) ‚â§ encodeToNat (Unite c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk74"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite a b))
‚â§ listToNat (encodeToList (Unite c b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk75"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList b ++ encodeToList a ++ [false])
‚â§ listToNat
    (encodeToList b ++ encodeToList c ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk76"><span class="nb">rewrite</span> !app_assoc, !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a)
‚â§ listToNat (encodeToList b ++ encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk77"><span class="nb">apply</span> listToNatAppLeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList a)
‚â§ listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">leafCount</span> (<span class="nv">x</span> : Tree) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; <span class="mi">1</span>
  | Unite a b =&gt; leafCount a + leafCount b
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk78"><span class="kn">Lemma</span> <span class="nf">oneLeqLeafCount</span> (<span class="nv">a</span> : Tree) : <span class="mi">1</span> &lt;= leafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> ‚â§ leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> ‚â§ leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb]; <span class="nb">simpl</span>; <span class="bp">now</span> (<span class="bp">done</span> || <span class="bp">lia</span>).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7a"><span class="kn">Lemma</span> <span class="nf">leafCountToLengthEncode</span> (<span class="nv">a</span> : Tree) : length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7c"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList Unit) = <span class="mi">2</span> * leafCount Unit - <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk7d"><hr></label><div class="goal-conclusion">length (encodeToList (Unite a b)) =
<span class="mi">2</span> * leafCount (Unite a b) - <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList Unit) = <span class="mi">2</span> * leafCount Unit - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk7f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList (Unite a b)) =
<span class="mi">2</span> * leafCount (Unite a b) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk81"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList b ++ encodeToList a ++ [false]) =
leafCount a + leafCount b +
(leafCount a + leafCount b + <span class="mi">0</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk82"><span class="nb">rewrite</span> !app_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList b) +
(length (encodeToList a) + length [false]) =
leafCount a + leafCount b +
(leafCount a + leafCount b + <span class="mi">0</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk83"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList b) +
(length (encodeToList a) + <span class="mi">1</span>) =
leafCount a + leafCount b +
(leafCount a + leafCount b + <span class="mi">0</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk84"><span class="nb">pose proof</span> oneLeqLeafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList b) +
(length (encodeToList a) + <span class="mi">1</span>) =
leafCount a + leafCount b +
(leafCount a + leafCount b + <span class="mi">0</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk85"><span class="nb">pose proof</span> oneLeqLeafCount b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length (encodeToList b) = <span class="mi">2</span> * leafCount b - <span class="mi">1</span></span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList b) +
(length (encodeToList a) + <span class="mi">1</span>) =
leafCount a + leafCount b +
(leafCount a + leafCount b + <span class="mi">0</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk86"><span class="kn">Lemma</span> <span class="nf">encodeToNatSubtermLeq2</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Tree) (<span class="nv">h</span> : encodeToNat a &lt;= encodeToNat c) (<span class="nv">hLeafCount</span> : leafCount a = leafCount c) : encodeToNat (Unite b a) &lt;= encodeToNat (Unite b c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk88"><span class="nb">pose proof</span> leafCountToLengthEncode a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk89"><span class="nb">pose proof</span> leafCountToLengthEncode c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8a"><span class="nb">pose proof</span> oneLeqLeafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8b"><span class="nb">pose proof</span> oneLeqLeafCount c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8c"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : length (encodeToList a) = length (encodeToList c)) <span class="kr">as</span> hLength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) ‚â§ encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8d"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite b a))
‚â§ listToNat (encodeToList (Unite b c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList a ++ encodeToList b ++ [false])
‚â§ listToNat
    (encodeToList c ++ encodeToList b ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk8f"><span class="nb">rewrite</span> !app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  ((encodeToList a ++ encodeToList b) ++ [false])
‚â§ listToNat
    ((encodeToList c ++ encodeToList b) ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk90"><span class="nb">rewrite</span> !listToNatFalse, !listToNatAppend.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b) +
listToNat (encodeToList a)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b) +
  listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk91"><span class="nb">assert</span> (step : <span class="mi">2</span>^(length (encodeToList a)) * listToNat (encodeToList b) &lt;= <span class="mi">2</span>^(length (encodeToList c)) * listToNat (encodeToList b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk92"><hr></label><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b) +
listToNat (encodeToList a)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b) +
  listToNat (encodeToList c)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk93">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk94"><span class="nb">rewrite</span> hLength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList c) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk95"><span class="nb">apply</span> (proj1 (Nat.mul_le_mono_pos_l _ _ _ (zeroLtPowerOfTwo (length (encodeToList c))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b)
‚â§ listToNat (encodeToList b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk96">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â§ encodeToNat c</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b) +
listToNat (encodeToList a)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b) +
  listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk97"><span class="nb">unfold</span> encodeToNat <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat (encodeToList a)
‚â§ listToNat (encodeToList c)</span></span></span><br><span><var>hLeafCount</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) =
length (encodeToList c)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ length (encodeToList a) *
listToNat (encodeToList b) +
listToNat (encodeToList a)
‚â§ <span class="mi">2</span> ^ length (encodeToList c) *
  listToNat (encodeToList b) +
  listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk98"><span class="kn">Lemma</span> <span class="nf">encodeToNatSubtermLt2</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Tree) (<span class="nv">h</span> : encodeToNat a &lt; encodeToNat c) (<span class="nv">hLength</span> : leafCount a = leafCount c): encodeToNat (Unite b a) &lt; encodeToNat (Unite b c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) &lt; encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite b a) &lt; encodeToNat (Unite b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9a"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite b a)) &lt;
listToNat (encodeToList (Unite b c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9b"><span class="nb">pose proof</span> leafCountToLengthEncode a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite b a)) &lt;
listToNat (encodeToList (Unite b c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9c"><span class="nb">pose proof</span> leafCountToLengthEncode c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite b a)) &lt;
listToNat (encodeToList (Unite b c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList a ++ encodeToList b ++ [false]) &lt;
listToNat
  (encodeToList c ++ encodeToList b ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9e"><span class="nb">rewrite</span> !app_assoc, !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList a ++ encodeToList b) &lt;
listToNat (encodeToList c ++ encodeToList b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk9f"><span class="nb">apply</span> listToNatAppLt&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList a) &lt;
listToNat (encodeToList c)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chka0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chka0"><hr></label><div class="goal-conclusion">length (encodeToList a) = length (encodeToList c)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList a) &lt;
listToNat (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>encodeToNat a &lt; encodeToNat c</span></span></span><br><span><var>hLength</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount c</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>length (encodeToList a) = <span class="mi">2</span> * leafCount a - <span class="mi">1</span></span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>length (encodeToList c) = <span class="mi">2</span> * leafCount c - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (encodeToList a) = length (encodeToList c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">score</span> (<span class="nv">x</span> : Tree) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; <span class="mi">0</span>
  | Unite a b =&gt; leafCount a + leafCount b + score a + score b
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">leftUniteCount</span> (<span class="nv">x</span> : Tree) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unite a _ =&gt; <span class="mi">1</span> + leftUniteCount a
  | Unit =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka3"><span class="kn">Lemma</span> <span class="nf">leftUniteCountLeqLeafCount</span> (<span class="nv">x</span> : Tree) : leftUniteCount x &lt;= leafCount x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount x ‚â§ leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount x ‚â§ leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka5"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount Unit ‚â§ leafCount Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ leafCount b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chka6"><hr></label><div class="goal-conclusion">leftUniteCount (Unite a b) ‚â§ leafCount (Unite a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount Unit ‚â§ leafCount Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite a b) ‚â§ leafCount (Unite a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkaa"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leftUniteCount a) ‚â§ leafCount a + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkab"><span class="nb">pose proof</span> oneLeqLeafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leftUniteCount a) ‚â§ leafCount a + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkac"><span class="nb">pose proof</span> oneLeqLeafCount b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leftUniteCount a) ‚â§ leafCount a + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">maxLeftUniteCount</span> (<span class="nv">x</span> : Tree) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unite a b =&gt; max (leftUniteCount x) (max (maxLeftUniteCount a) (maxLeftUniteCount b))
  | Unit =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">totalUniteCount</span> (<span class="nv">x</span> : Tree) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unite a b =&gt; <span class="mi">1</span> + totalUniteCount a + totalUniteCount b
  | Unit =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkad"><span class="kn">Lemma</span> <span class="nf">leftUniteCountLeqTotalUniteCount</span> (<span class="nv">x</span> : Tree) : leftUniteCount x &lt;= totalUniteCount x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount x ‚â§ totalUniteCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount x ‚â§ totalUniteCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkaf"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount Unit ‚â§ totalUniteCount Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ totalUniteCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ totalUniteCount b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkb0"><hr></label><div class="goal-conclusion">leftUniteCount (Unite a b)
‚â§ totalUniteCount (Unite a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount Unit ‚â§ totalUniteCount Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ totalUniteCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ totalUniteCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite a b)
‚â§ totalUniteCount (Unite a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb3"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leftUniteCount a ‚â§ totalUniteCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leftUniteCount b ‚â§ totalUniteCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leftUniteCount a)
‚â§ S (totalUniteCount a + totalUniteCount b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb4"><span class="kn">Lemma</span> <span class="nf">totalUniteCountPlusOne</span> (<span class="nv">x</span> : Tree) : <span class="mi">1</span> + totalUniteCount x = leafCount x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount x = leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount x = leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb6"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount Unit = leafCount Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount a = leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount b = leafCount b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkb7"><hr></label><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount (Unite a b) =
leafCount (Unite a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount Unit = leafCount Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount a = leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount b = leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + totalUniteCount (Unite a b) =
leafCount (Unite a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkba"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount a = leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + totalUniteCount b = leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S (totalUniteCount a + totalUniteCount b)) =
leafCount a + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkbb"><span class="kn">Lemma</span> <span class="nf">rewriteRule1</span> (<span class="nv">a</span> <span class="nv">b</span> : Tree) : score (Unite Unit (Unite a b)) = score (Unite (Unite a b) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit (Unite a b)) =
score (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkbc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit (Unite a b)) =
score (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkbd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (leafCount a + leafCount b + <span class="mi">0</span> +
   (leafCount a + leafCount b + score a + score b)) =
leafCount a + leafCount b + <span class="mi">1</span> +
(leafCount a + leafCount b + score a + score b) + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">hasRule1</span> (<span class="nv">x</span> : Tree) : bool :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unite Unit (Unite a b) =&gt; true
  | Unite a b =&gt; orb (hasRule1 a) (hasRule1 b)
  | Unit =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">replaceRule1</span> (<span class="nv">x</span> : Tree) : Tree :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unite Unit (Unite a b) =&gt; Unite (Unite a b) Unit
  | Unite a b =&gt; Unite (replaceRule1 a) (replaceRule1 b)
  | Unit =&gt; Unit
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkbe"><span class="kn">Lemma</span> <span class="nf">rule1_a</span> (<span class="nv">a</span> <span class="nv">b</span> : Tree) : leftUniteCount (Unite Unit (Unite a b)) &lt; leftUniteCount (Unite (Unite a b) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite Unit (Unite a b)) &lt;
leftUniteCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkbf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite Unit (Unite a b)) &lt;
leftUniteCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc0"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &lt; S (S (leftUniteCount a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc1"><span class="kn">Lemma</span> <span class="nf">rule1_a1</span> (<span class="nv">a</span> <span class="nv">b</span> : Tree) : encodeToNat (Unite Unit (Unite a b)) &gt; encodeToNat (Unite (Unite a b) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit (Unite a b)) &gt;
encodeToNat (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit (Unite a b)) &gt;
encodeToNat (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc3"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList (Unite Unit (Unite a b))) &gt;
listToNat (encodeToList (Unite (Unite a b) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  ((encodeToList b ++ encodeToList a ++ [false]) ++
   [true; false]) &gt;
listToNat
  ((encodeToList b ++ encodeToList a ++ [false]) ++
   [false]) +
(listToNat
   ((encodeToList b ++ encodeToList a ++ [false]) ++
    [false]) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc5"><span class="nb">rewrite</span> !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  ((encodeToList b ++ encodeToList a ++ [false]) ++
   [true; false]) &gt;
listToNat
  (encodeToList b ++ encodeToList a ++ [false]) +
(listToNat
   (encodeToList b ++ encodeToList a ++ [false]) + <span class="mi">0</span>) +
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc6"><span class="nb">rewrite</span> app_assoc, !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (((encodeToList b ++ encodeToList a) ++ [false]) ++
   [true; false]) &gt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc7"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(listsEqual) : ((encodeToList b ++ encodeToList a) ++ [false]) ++ [true; false] = (((encodeToList b ++ encodeToList a) ++ [false]) ++ [true]) ++ [false]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  ((((encodeToList b ++ encodeToList a) ++ [false]) ++
    [true]) ++ [false]) &gt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc8"><span class="nb">rewrite</span> !listToNatFalse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (((encodeToList b ++ encodeToList a) ++ [false]) ++
   [true]) &gt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkc9"><span class="nb">pose proof</span> listToNatFalseTrue (encodeToList b ++ encodeToList a) <span class="kr">as</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>listToNat
  (((encodeToList b ++ encodeToList a) ++ [false]) ++
   [true]) &gt;
listToNat (encodeToList b ++ encodeToList a) +
listToNat (encodeToList b ++ encodeToList a) + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (((encodeToList b ++ encodeToList a) ++ [false]) ++
   [true]) &gt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkca"><span class="kn">Lemma</span> <span class="nf">rule1_replace_leafCount</span> (<span class="nv">a</span> : Tree) : leafCount a = leafCount (replaceRule1 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a = leafCount (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkcb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a = leafCount (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkcc"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule1 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkcd"><hr></label><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule1 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule1 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkcf"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule1 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b =
leafCount
  <span class="kr">match</span> a <span class="kr">with</span>
  | Unit =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt;
          Unite (replaceRule1 a) (replaceRule1 b)
      | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
      <span class="kr">end</span>
  | Unite _ _ =&gt;
      Unite (replaceRule1 a) (replaceRule1 b)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd2"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b =
leafCount
  <span class="kr">match</span> b <span class="kr">with</span>
  | Unit =&gt; Unite (replaceRule1 Unit) (replaceRule1 b)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkd3"><hr></label><div class="goal-conclusion">leafCount (Unite _0 _1) + leafCount b =
leafCount
  (Unite (replaceRule1 (Unite _0 _1)) (replaceRule1 b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b =
leafCount
  <span class="kr">match</span> b <span class="kr">with</span>
  | Unit =&gt; Unite (replaceRule1 Unit) (replaceRule1 b)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd5"><span class="nb">destruct</span> b; <span class="nb">rewrite</span> <span class="nl">?IHa</span>, <span class="nl">?IHb</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (replaceRule1 Unit) +
leafCount (replaceRule1 Unit) =
leafCount
  (Unite (replaceRule1 Unit) (replaceRule1 Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkd6"><hr></label><div class="goal-conclusion">leafCount (replaceRule1 Unit) +
leafCount (replaceRule1 (Unite _0 _1)) =
leafCount (Unite (Unite _0 _1) Unit)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (replaceRule1 Unit) +
leafCount (replaceRule1 Unit) =
leafCount
  (Unite (replaceRule1 Unit) (replaceRule1 Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkd9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (replaceRule1 Unit) +
leafCount (replaceRule1 (Unite _0 _1)) =
leafCount (Unite (Unite _0 _1) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkda"><span class="nb">rewrite</span> &lt;- !IHa, &lt;- !IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount (Unite _0 _1) =
leafCount (Unite (Unite _0 _1) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkdb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leafCount _0 + leafCount _1) =
leafCount _0 + leafCount _1 + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkdc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite _0 _1) + leafCount b =
leafCount
  (Unite (replaceRule1 (Unite _0 _1)) (replaceRule1 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkdd"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b), &lt;- !IHa, &lt;- !IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount _0 + leafCount _1 + leafCount b =
leafCount (Unite _0 _1) + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkde"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>_0, _1, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite _0 _1) = leafCount (replaceRule1 (Unite _0 _1))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount _0 + leafCount _1 + leafCount b =
leafCount _0 + leafCount _1 + leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkdf"><span class="kn">Lemma</span> <span class="nf">rule1_replace_score</span> (<span class="nv">a</span> : Tree) : score a = score (replaceRule1 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score a = score (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score a = score (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke1"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit = score (replaceRule1 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b = score (replaceRule1 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chke2"><hr></label><div class="goal-conclusion">score (Unite a b) = score (replaceRule1 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit = score (replaceRule1 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b = score (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) = score (replaceRule1 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke6"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a Unit) =
score (replaceRule1 (Unite a Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chke7"><hr></label><div class="goal-conclusion">score (Unite a (Unite b1 b2)) =
score (replaceRule1 (Unite a (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a Unit) =
score (replaceRule1 (Unite a Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chke9"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit Unit) =
score (replaceRule1 (Unite Unit Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkea"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) =
score (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkeb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit Unit) =
score (replaceRule1 (Unite Unit Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkec"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chked">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) =
score (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkee"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule1 (Unite (Unite a1 a2) Unit) = Unite (replaceRule1 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) =
score (Unite (replaceRule1 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkef"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2 =
score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
score Unit =
leafCount (replaceRule1 (Unite a1 a2)) +
leafCount Unit + score (replaceRule1 (Unite a1 a2)) +
score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf0"><span class="nb">rewrite</span> &lt;- !IHa, rule1_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2 =
score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (replaceRule1 (Unite a1 a2)) +
leafCount Unit +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
score Unit =
leafCount (replaceRule1 (Unite a1 a2)) +
leafCount Unit +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a = score (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a (Unite b1 b2)) =
score (replaceRule1 (Unite a (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf2"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit (Unite b1 b2)) =
score (replaceRule1 (Unite Unit (Unite b1 b2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkf3"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) =
score
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit (Unite b1 b2)) =
score (replaceRule1 (Unite Unit (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit = score (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (leafCount b1 + leafCount b2 + <span class="mi">0</span> +
   (leafCount b1 + leafCount b2 + score b1 + score b2)) =
leafCount b1 + leafCount b2 + <span class="mi">1</span> +
(leafCount b1 + leafCount b2 + score b1 + score b2) +
<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) =
score
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf7"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)) = Unite (replaceRule1 (Unite a1 a2)) (replaceRule1 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) = score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) = score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) =
score
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf8"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2 =
score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2 =
score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2) =
leafCount (replaceRule1 (Unite a1 a2)) +
leafCount (replaceRule1 (Unite b1 b2)) +
score (replaceRule1 (Unite a1 a2)) +
score (replaceRule1 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkf9"><span class="nb">rewrite</span> &lt;- !IHa , &lt;- !IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2 =
score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2 =
score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2) =
leafCount (replaceRule1 (Unite a1 a2)) +
leafCount (replaceRule1 (Unite b1 b2)) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkfa"><span class="nb">rewrite</span> &lt;- !rule1_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2 =
score (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2 =
score (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2) =
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkfb"><span class="kn">Lemma</span> <span class="nf">rule1_replace&#39;</span> (<span class="nv">a</span> : Tree) : encodeToNat a &gt;= encodeToNat (replaceRule1 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a ‚â• encodeToNat (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a ‚â• encodeToNat (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkfd"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat (replaceRule1 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chkfe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â• encodeToNat (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule1 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chkfe"><hr></label><div class="goal-conclusion">encodeToNat (Unite a b)
‚â• encodeToNat (replaceRule1 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chkff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat (replaceRule1 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk100"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk101">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â• encodeToNat (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b)
‚â• encodeToNat (replaceRule1 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk102"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2]; <span class="nb">destruct</span> b <span class="kr">as</span> [| [| b11 b12] b2]; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">lia</span>; <span class="kp">try</span> <span class="nb">apply</span> (Nat.lt_le_incl _ _ (rule1_a1 _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span> Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk103" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
<span class="kr">match</span> b2 <span class="kr">with</span>
| Unit =&gt; Unite Unit (replaceRule1 b2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk103"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk104" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
(Unite
<span class="kr">match</span> b11 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> b12 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 b11) (replaceRule1 b12)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 b11) (replaceRule1 b12)
<span class="kr">end</span> (replaceRule1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk104"><hr></label><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk105">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span> Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk106"><span class="nb">apply</span> encodeToNatSubtermLeq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  <span class="kr">match</span> a1 <span class="kr">with</span>
  | Unit =&gt;
      <span class="kr">match</span> a2 <span class="kr">with</span>
      | Unit =&gt;
          Unite (replaceRule1 a1) (replaceRule1 a2)
      | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
      <span class="kr">end</span>
  | Unite _ _ =&gt;
      Unite (replaceRule1 a1) (replaceRule1 a2)
  <span class="kr">end</span> ‚â§ encodeToNat (Unite a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk107">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
<span class="kr">match</span> b2 <span class="kr">with</span>
| Unit =&gt; Unite Unit (replaceRule1 b2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk108"><span class="nb">pose proof</span> encodeToNatSubtermLeq1 _ (Unite Unit b2) _ IHa <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
<span class="kr">match</span> a1 <span class="kr">with</span>
| Unit =&gt;
<span class="kr">match</span> a2 <span class="kr">with</span>
| Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span>
| Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2)
<span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
<span class="kr">match</span> b2 <span class="kr">with</span>
| Unit =&gt; Unite Unit (replaceRule1 b2)
| Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
<span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk109"><span class="nb">assert</span> (hL : leafCount <span class="kr">match</span> b2 <span class="kr">with</span> | Unit =&gt; Unite Unit (replaceRule1 b2) | Unite a b =&gt; Unite (Unite a b) Unit <span class="kr">end</span> = leafCount (Unite Unit b2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
    <span class="kr">match</span> b2 <span class="kr">with</span>
    | Unit =&gt; Unite Unit (replaceRule1 b2)
    | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
    <span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  <span class="kr">match</span> b2 <span class="kr">with</span>
  | Unit =&gt; Unite Unit (replaceRule1 b2)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span> = leafCount (Unite Unit b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
    <span class="kr">match</span> b2 <span class="kr">with</span>
    | Unit =&gt; Unite Unit (replaceRule1 b2)
    | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
    <span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  <span class="kr">match</span> b2 <span class="kr">with</span>
  | Unit =&gt; Unite Unit (replaceRule1 b2)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span> = leafCount (Unite Unit b2)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk10a"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk10b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
    <span class="kr">match</span> b2 <span class="kr">with</span>
    | Unit =&gt; Unite Unit (replaceRule1 b2)
    | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
    <span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  <span class="kr">match</span> b2 <span class="kr">with</span>
  | Unit =&gt; Unite Unit (replaceRule1 b2)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span> = leafCount (Unite Unit b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk10c"><span class="nb">destruct</span> b2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit Unit)
‚â• encodeToNat (Unite Unit (replaceRule1 Unit))</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit Unit))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit Unit))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (replaceRule1 Unit)) =
leafCount (Unite Unit Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit (Unite _0 _1))
‚â• encodeToNat (Unite (Unite _0 _1) Unit)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit (Unite _0 _1)))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite Unit (Unite _0 _1)))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk10d"><hr></label><div class="goal-conclusion">leafCount (Unite (Unite _0 _1) Unit) =
leafCount (Unite Unit (Unite _0 _1))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk10e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit Unit)
‚â• encodeToNat (Unite Unit (replaceRule1 Unit))</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit Unit))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit Unit))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (replaceRule1 Unit)) =
leafCount (Unite Unit Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk10f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit (Unite _0 _1))
‚â• encodeToNat (Unite (Unite _0 _1) Unit)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit (Unite _0 _1)))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite Unit (Unite _0 _1)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite _0 _1) Unit) =
leafCount (Unite Unit (Unite _0 _1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk110"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _0, _1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit (Unite _0 _1))
‚â• encodeToNat (Unite (Unite _0 _1) Unit)</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit (Unite _0 _1)))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite Unit (Unite _0 _1)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount _0 + leafCount _1 + <span class="mi">1</span> =
S (leafCount _0 + leafCount _1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk111">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
    <span class="kr">match</span> b2 <span class="kr">with</span>
    | Unit =&gt; Unite Unit (replaceRule1 b2)
    | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
    <span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  <span class="kr">match</span> b2 <span class="kr">with</span>
  | Unit =&gt; Unite Unit (replaceRule1 b2)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span> = leafCount (Unite Unit b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk112"><span class="nb">pose proof</span> encodeToNatSubtermLeq2 _ (<span class="kr">match</span> a1 <span class="kr">with</span> | Unit =&gt; <span class="kr">match</span> a2 <span class="kr">with</span> | Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2) | Unite a b =&gt; Unite (Unite a b) Unit <span class="kr">end</span> | Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2) <span class="kr">end</span>) _ IHb hL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite Unit b2)
‚â• encodeToNat
    <span class="kr">match</span> b2 <span class="kr">with</span>
    | Unit =&gt; Unite Unit (replaceRule1 b2)
    | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
    <span class="kr">end</span></span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite Unit b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2) (Unite Unit b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  <span class="kr">match</span> b2 <span class="kr">with</span>
  | Unit =&gt; Unite Unit (replaceRule1 b2)
  | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
  <span class="kr">end</span> = leafCount (Unite Unit b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span>
     <span class="kr">match</span> b2 <span class="kr">with</span>
     | Unit =&gt; Unite Unit (replaceRule1 b2)
     | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
     <span class="kr">end</span>)
‚â§ encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1)
             (replaceRule1 a2)
       <span class="kr">end</span> (Unite Unit b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite Unit b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       <span class="kr">match</span> b2 <span class="kr">with</span>
       | Unit =&gt; Unite Unit (replaceRule1 b2)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk113">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk114"><span class="nb">pose proof</span> encodeToNatSubtermLeq1 _ (Unite (Unite b11 b12) b2) _ IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk115"><span class="nb">assert</span> (hL : leafCount (Unite <span class="kr">match</span> b11 <span class="kr">with</span> | Unit =&gt; <span class="kr">match</span> b12 <span class="kr">with</span> | Unit =&gt; Unite (replaceRule1 b11) (replaceRule1 b12) | Unite a b =&gt; Unite (Unite a b) Unit <span class="kr">end</span> | Unite _ _ =&gt; Unite (replaceRule1 b11) (replaceRule1 b12) <span class="kr">end</span> (replaceRule1 b2)) = leafCount (Unite (Unite b11 b12) b2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     <span class="kr">match</span> b11 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> b12 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 b11)
               (replaceRule1 b12)
         | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 b11) (replaceRule1 b12)
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite b11 b12) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  (Unite
     <span class="kr">match</span> b11 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> b12 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 b11)
               (replaceRule1 b12)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 b11)
           (replaceRule1 b12)
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite b11 b12) b2)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk116"><hr></label><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk117">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     <span class="kr">match</span> b11 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> b12 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 b11)
               (replaceRule1 b12)
         | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 b11) (replaceRule1 b12)
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite b11 b12) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk118"><span class="nb">destruct</span> b11.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite Unit b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b12 <span class="kr">with</span>
       | Unit =&gt;
           Unite (replaceRule1 Unit)
             (replaceRule1 b12)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     <span class="kr">match</span> b12 <span class="kr">with</span>
     | Unit =&gt;
         Unite (replaceRule1 Unit) (replaceRule1 b12)
     | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite Unit b12) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite (Unite _1 _2) b12) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 (Unite _1 _2))
          (replaceRule1 b12)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite (Unite _1 _2) b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite (Unite _1 _2) b12) b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk119"><hr></label><div class="goal-conclusion">leafCount
  (Unite
     (Unite (replaceRule1 (Unite _1 _2))
        (replaceRule1 b12)) 
     (replaceRule1 b2)) =
leafCount (Unite (Unite (Unite _1 _2) b12) b2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite Unit b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b12 <span class="kr">with</span>
       | Unit =&gt;
           Unite (replaceRule1 Unit)
             (replaceRule1 b12)
       | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     <span class="kr">match</span> b12 <span class="kr">with</span>
     | Unit =&gt;
         Unite (replaceRule1 Unit) (replaceRule1 b12)
     | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite Unit b12) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11b"><span class="nb">destruct</span> b12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite Unit Unit) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 Unit)
          (replaceRule1 Unit)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit Unit) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit Unit) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     (Unite (replaceRule1 Unit) (replaceRule1 Unit))
     (replaceRule1 b2)) =
leafCount (Unite (Unite Unit Unit) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk11c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite Unit (Unite _1 _2)) b2)
‚â• encodeToNat
    (Unite (Unite (Unite _1 _2) Unit)
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit (Unite _1 _2)) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit (Unite _1 _2)) b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk11c"><hr></label><div class="goal-conclusion">leafCount
  (Unite (Unite (Unite _1 _2) Unit) (replaceRule1 b2)) =
leafCount (Unite (Unite Unit (Unite _1 _2)) b2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite Unit Unit) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 Unit)
          (replaceRule1 Unit)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit Unit) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit Unit) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     (Unite (replaceRule1 Unit) (replaceRule1 Unit))
     (replaceRule1 b2)) =
leafCount (Unite (Unite Unit Unit) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11e"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b), &lt;- !rule1_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite Unit Unit) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 Unit)
          (replaceRule1 Unit)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit Unit) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit Unit) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount Unit + leafCount b2 =
leafCount Unit + leafCount Unit + leafCount b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk11f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite Unit (Unite _1 _2)) b2)
‚â• encodeToNat
    (Unite (Unite (Unite _1 _2) Unit)
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit (Unite _1 _2)) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit (Unite _1 _2)) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite (Unite (Unite _1 _2) Unit) (replaceRule1 b2)) =
leafCount (Unite (Unite Unit (Unite _1 _2)) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk120"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b), &lt;- !rule1_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite Unit (Unite _1 _2)) b2)
‚â• encodeToNat
    (Unite (Unite (Unite _1 _2) Unit)
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite Unit (Unite _1 _2)) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite Unit (Unite _1 _2)) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount _1 + leafCount _2 + leafCount Unit +
leafCount b2 =
leafCount Unit + (leafCount _1 + leafCount _2) +
leafCount b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk121">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite (Unite _1 _2) b12) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 (Unite _1 _2))
          (replaceRule1 b12)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite (Unite _1 _2) b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite (Unite _1 _2) b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount
  (Unite
     (Unite (replaceRule1 (Unite _1 _2))
        (replaceRule1 b12)) 
     (replaceRule1 b2)) =
leafCount (Unite (Unite (Unite _1 _2) b12) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk122"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b), &lt;- !rule1_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite (Unite _1 _2) b12) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 (Unite _1 _2))
          (replaceRule1 b12)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite (Unite _1 _2) b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite (Unite _1 _2) b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite _1 _2) + leafCount b12 + leafCount b2 =
leafCount _1 + leafCount _2 + leafCount b12 +
leafCount b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk123"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, _1, _2, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite (Unite _1 _2) b12) b2)
‚â• encodeToNat
    (Unite
       (Unite (replaceRule1 (Unite _1 _2))
          (replaceRule1 b12)) 
       (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite (Unite _1 _2) b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite (Unite _1 _2) b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount _1 + leafCount _2 + leafCount b12 +
leafCount b2 =
leafCount _1 + leafCount _2 + leafCount b12 +
leafCount b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk124">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  (Unite
     <span class="kr">match</span> b11 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> b12 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 b11)
               (replaceRule1 b12)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 b11)
           (replaceRule1 b12)
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite b11 b12) b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk125"><span class="nb">pose proof</span> encodeToNatSubtermLeq2 _ (<span class="kr">match</span> a1 <span class="kr">with</span> | Unit =&gt; <span class="kr">match</span> a2 <span class="kr">with</span> | Unit =&gt; Unite (replaceRule1 a1) (replaceRule1 a2) | Unite a b =&gt; Unite (Unite a b) Unit <span class="kr">end</span> | Unite _ _ =&gt; Unite (replaceRule1 a1) (replaceRule1 a2) <span class="kr">end</span>) _ IHb hL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b11, b12, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2)
‚â• encodeToNat
    <span class="kr">match</span> a1 <span class="kr">with</span>
    | Unit =&gt;
        <span class="kr">match</span> a2 <span class="kr">with</span>
        | Unit =&gt;
            Unite (replaceRule1 a1)
              (replaceRule1 a2)
        | Unite _0 _1 =&gt;
            Unite (Unite _0 _1) Unit
        <span class="kr">end</span>
    | Unite _ _ =&gt;
        Unite (replaceRule1 a1)
          (replaceRule1 a2)
    <span class="kr">end</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite b11 b12) b2)
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> b11 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> b12 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 b11)
                 (replaceRule1 b12)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 b11)
             (replaceRule1 b12)
       <span class="kr">end</span> (replaceRule1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span> (Unite (Unite b11 b12) b2))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (Unite (Unite b11 b12) b2))</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>leafCount
  (Unite
     <span class="kr">match</span> b11 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> b12 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 b11)
               (replaceRule1 b12)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 b11)
           (replaceRule1 b12)
     <span class="kr">end</span> (replaceRule1 b2)) =
leafCount (Unite (Unite b11 b12) b2)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite
     <span class="kr">match</span> a1 <span class="kr">with</span>
     | Unit =&gt;
         <span class="kr">match</span> a2 <span class="kr">with</span>
         | Unit =&gt;
             Unite (replaceRule1 a1)
               (replaceRule1 a2)
         | Unite _0 _1 =&gt;
             Unite (Unite _0 _1) Unit
         <span class="kr">end</span>
     | Unite _ _ =&gt;
         Unite (replaceRule1 a1)
           (replaceRule1 a2)
     <span class="kr">end</span>
     (Unite
        <span class="kr">match</span> b11 <span class="kr">with</span>
        | Unit =&gt;
            <span class="kr">match</span> b12 <span class="kr">with</span>
            | Unit =&gt;
                Unite (replaceRule1 b11)
                  (replaceRule1 b12)
            | Unite _0 _1 =&gt;
                Unite (Unite _0 _1) Unit
            <span class="kr">end</span>
        | Unite _ _ =&gt;
            Unite (replaceRule1 b11)
              (replaceRule1 b12)
        <span class="kr">end</span> (replaceRule1 b2)))
‚â§ encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt;
               Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1)
             (replaceRule1 a2)
       <span class="kr">end</span> (Unite (Unite b11 b12) b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (Unite (Unite a1 a2) (Unite (Unite b11 b12) b2))
‚â• encodeToNat
    (Unite
       <span class="kr">match</span> a1 <span class="kr">with</span>
       | Unit =&gt;
           <span class="kr">match</span> a2 <span class="kr">with</span>
           | Unit =&gt;
               Unite (replaceRule1 a1)
                 (replaceRule1 a2)
           | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
           <span class="kr">end</span>
       | Unite _ _ =&gt;
           Unite (replaceRule1 a1) (replaceRule1 a2)
       <span class="kr">end</span>
       (Unite
          <span class="kr">match</span> b11 <span class="kr">with</span>
          | Unit =&gt;
              <span class="kr">match</span> b12 <span class="kr">with</span>
              | Unit =&gt;
                  Unite (replaceRule1 b11)
                    (replaceRule1 b12)
              | Unite _0 _1 =&gt;
                  Unite (Unite _0 _1) Unit
              <span class="kr">end</span>
          | Unite _ _ =&gt;
              Unite (replaceRule1 b11)
                (replaceRule1 b12)
          <span class="kr">end</span> (replaceRule1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk126"><span class="kn">Lemma</span> <span class="nf">rule1_replace</span> (<span class="nv">a</span> : Tree) (<span class="nv">h</span> : hasRule1 a) : encodeToNat a &gt; encodeToNat (replaceRule1 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a &gt; encodeToNat (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk127"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a &gt; encodeToNat (replaceRule1 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk128"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 a ‚Üí encodeToNat a &gt; encodeToNat (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule1 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk129"><hr></label><div class="goal-conclusion">encodeToNat (Unite a b) &gt;
encodeToNat (replaceRule1 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk12a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk12b"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk12c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 a ‚Üí encodeToNat a &gt; encodeToNat (replaceRule1 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule1 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) &gt;
encodeToNat (replaceRule1 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk12d"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2]; <span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2]; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> h; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit (Unite b1 b2)) &gt;
encodeToNat (replaceRule1 (Unite Unit (Unite b1 b2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk12e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk12e"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk12f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk12f"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk130">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit (Unite b1 b2)) &gt;
encodeToNat (replaceRule1 (Unite Unit (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk131"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit (Unite b1 b2)) &gt;
encodeToNat (Unite (Unite b1 b2) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rule1_a1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk133"><span class="nb">assert</span> (h1 : hasRule1 (Unite (Unite a1 a2) Unit) = hasRule1 (Unite a1 a2) || false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2) || false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk134" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2) || false</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk134"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk135">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2) || false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk136">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2) || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk137"><span class="nb">rewrite</span> orb_false_r <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk138"><span class="nb">rewrite</span> h1 <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk139"><span class="nb">pose proof</span> IHa h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule1 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13a"><span class="nb">apply</span> encodeToNatSubtermLt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule1 Unit)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) =
hasRule1 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  <span class="kr">match</span> a1 <span class="kr">with</span>
  | Unit =&gt;
      <span class="kr">match</span> a2 <span class="kr">with</span>
      | Unit =&gt;
          Unite
            ((<span class="kr">fix</span> _0 (_1 : Tree) : Tree :=
                <span class="kr">match</span> _1 <span class="kr">with</span>
                | Unit =&gt; Unit
                | Unite (Unit <span class="kr">as</span> _2) (Unite _4 _5) =&gt;
                    Unite (Unite _4 _5) Unit
                | Unite (Unit <span class="kr">as</span> _2) (Unit <span class="kr">as</span> _3) |
                  Unite (Unite _ _ <span class="kr">as</span> _2) _3 =&gt;
                    Unite (_0 _2) (_0 _3)
                <span class="kr">end</span>) a1)
            ((<span class="kr">fix</span> _0 (_1 : Tree) : Tree :=
                <span class="kr">match</span> _1 <span class="kr">with</span>
                | Unit =&gt; Unit
                | Unite (Unit <span class="kr">as</span> _2) (Unite _4 _5) =&gt;
                    Unite (Unite _4 _5) Unit
                | Unite (Unit <span class="kr">as</span> _2) (Unit <span class="kr">as</span> _3) |
                  Unite (Unite _ _ <span class="kr">as</span> _2) _3 =&gt;
                    Unite (_0 _2) (_0 _3)
                <span class="kr">end</span>) a2)
      | Unite _0 _1 =&gt; Unite (Unite _0 _1) Unit
      <span class="kr">end</span>
  | Unite _ _ =&gt;
      Unite
        ((<span class="kr">fix</span> _2 (_3 : Tree) : Tree :=
            <span class="kr">match</span> _3 <span class="kr">with</span>
            | Unit =&gt; Unit
            | Unite (Unit <span class="kr">as</span> _4) (Unite _6 _7) =&gt;
                Unite (Unite _6 _7) Unit
            | Unite (Unit <span class="kr">as</span> _4) (Unit <span class="kr">as</span> _5) |
              Unite (Unite _ _ <span class="kr">as</span> _4) _5 =&gt;
                Unite (_2 _4) (_2 _5)
            <span class="kr">end</span>) a1)
        ((<span class="kr">fix</span> _2 (_3 : Tree) : Tree :=
            <span class="kr">match</span> _3 <span class="kr">with</span>
            | Unit =&gt; Unit
            | Unite (Unit <span class="kr">as</span> _4) (Unite _6 _7) =&gt;
                Unite (Unite _6 _7) Unit
            | Unite (Unit <span class="kr">as</span> _4) (Unit <span class="kr">as</span> _5) |
              Unite (Unite _ _ <span class="kr">as</span> _4) _5 =&gt;
                Unite (_2 _4) (_2 _5)
            <span class="kr">end</span>) a2)
  <span class="kr">end</span> &lt; encodeToNat (Unite a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13c"><span class="nb">assert</span> (h1 : hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) = hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk13d"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk13f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk140"><span class="nb">rewrite</span> h1 <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk141"><span class="nb">assert</span> (h2 : encodeToNat (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2))) = encodeToNat (Unite (replaceRule1 (Unite a1 a2)) (replaceRule1 (Unite b1 b2)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2))) =
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk142" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (replaceRule1
     (Unite (Unite a1 a2) (Unite b1 b2))) =
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk142"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk143">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2))) =
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk144">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (replaceRule1
     (Unite (Unite a1 a2) (Unite b1 b2))) =
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule1 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk145"><span class="nb">rewrite</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (replaceRule1
     (Unite (Unite a1 a2) (Unite b1 b2))) =
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk146"><span class="nb">clear</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk147"><span class="nb">destruct</span> (orb_prop_elim _ _ h) <span class="kr">as</span> [H | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk148" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk148"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk149">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14a"><span class="nb">pose proof</span> IHa H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14b"><span class="nb">pose proof</span> encodeToNatSubtermLt1 (replaceRule1 (Unite a1 a2)) (Unite b1 b2) (Unite a1 a2) <span class="kp">ltac</span>:(<span class="nb">pose proof</span> rule1_replace&#39; (Unite a1 a2); <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (Unite b1 b2)) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14c"><span class="nb">pose proof</span> encodeToNatSubtermLeq2 _ (replaceRule1 (Unite a1 a2)) _ (rule1_replace&#39; (Unite b1 b2)) <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule1_replace_leafCount).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (Unite b1 b2)) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))
‚â§ encodeToNat
    (Unite (replaceRule1 (Unite a1 a2))
       (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14e"><span class="nb">pose proof</span> IHb H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) &gt;
encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk14f"><span class="nb">pose proof</span> encodeToNatSubtermLt2 (replaceRule1 (Unite b1 b2)) (Unite a1 a2) (Unite b1 b2) <span class="kp">ltac</span>:(<span class="nb">pose proof</span> rule1_replace&#39; (Unite b1 b2); <span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule1_replace_leafCount).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) &gt;
encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite a1 a2)
     (replaceRule1 (Unite b1 b2))) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk150"><span class="nb">pose proof</span> encodeToNatSubtermLeq1 (replaceRule1 (Unite a1 a2)) (replaceRule1 (Unite b1 b2)) (Unite a1 a2) (rule1_replace&#39; (Unite a1 a2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule1 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) &gt;
encodeToNat (replaceRule1 (Unite b1 b2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite a1 a2)
     (replaceRule1 (Unite b1 b2))) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (replaceRule1 (Unite b1 b2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule1 (Unite a1 a2))
     (replaceRule1 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk151"><span class="kn">Lemma</span> <span class="nf">rule1_b</span> (<span class="nv">a</span> <span class="nv">b</span> : Tree) : totalUniteCount (Unite Unit (Unite a b)) = totalUniteCount (Unite (Unite a b) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite Unit (Unite a b)) =
totalUniteCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk152"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite Unit (Unite a b)) =
totalUniteCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk153"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S (totalUniteCount a + totalUniteCount b)) =
S (S (totalUniteCount a + totalUniteCount b + <span class="mi">0</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk154"><span class="kn">Lemma</span> <span class="nf">rule1_c</span> (<span class="nv">a</span> <span class="nv">b</span> : Tree) : leafCount (Unite Unit (Unite a b)) = leafCount (Unite (Unite a b) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (Unite a b)) =
leafCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk155"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (Unite a b)) =
leafCount (Unite (Unite a b) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk156"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leafCount a + leafCount b) =
leafCount a + leafCount b + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk157"><span class="kn">Lemma</span> <span class="nf">rewriteRule2</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) (<span class="nv">h</span> : leafCount a &gt;= leafCount d) : score (Unite (Unite a b) (Unite c d)) &lt;= score (Unite (Unite (Unite a b) c) d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a ‚â• leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a b) (Unite c d))
‚â§ score (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk158"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a ‚â• leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a b) (Unite c d))
‚â§ score (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk159"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a ‚â• leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b +
(leafCount c + leafCount d) +
(leafCount a + leafCount b + score a + score b) +
(leafCount c + leafCount d + score c + score d)
‚â§ leafCount a + leafCount b + leafCount c +
  leafCount d +
  (leafCount a + leafCount b + leafCount c +
   (leafCount a + leafCount b + score a + score b) +
   score c) + score d</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">hasRule2</span> (<span class="nv">x</span> : Tree) : bool :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; false
  | Unite a b =&gt;
    <span class="kr">match</span> a <span class="kr">with</span>
    | Unit =&gt; hasRule2 b
    | Unite a0 b0 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt; hasRule2 a
      | Unite c d =&gt;
        (leafCount d &lt;=? leafCount a0) || hasRule2 a || hasRule2 b
      <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">replaceRule2</span> (<span class="nv">x</span> : Tree) : Tree :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; Unit
  | Unite a b =&gt;
    <span class="kr">match</span> a <span class="kr">with</span>
    | Unit =&gt; Unite (replaceRule2 a) (replaceRule2 b)
    | Unite a0 b0 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt; Unite (replaceRule2 a) (replaceRule2 b)
      | Unite c d =&gt;
        <span class="kr">if</span> leafCount d &lt;=? leafCount a0
        <span class="kr">then</span> Unite (Unite (Unite a0 b0) c) d
        <span class="kr">else</span> Unite (replaceRule2 a) (replaceRule2 b)
      <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15a"><span class="kn">Lemma</span> <span class="nf">rule2_a</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : leftUniteCount (Unite (Unite a b) (Unite c d)) &lt; leftUniteCount (Unite (Unite (Unite a b) c) d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite (Unite a b) (Unite c d)) &lt;
leftUniteCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leftUniteCount (Unite (Unite a b) (Unite c d)) &lt;
leftUniteCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S (leftUniteCount a)) &lt;
S (S (S (leftUniteCount a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15d"><span class="kn">Lemma</span> <span class="nf">rule2_a1</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : encodeToNat (Unite (Unite a b) (Unite c d)) &gt; encodeToNat (Unite (Unite (Unite a b) c) d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a b) (Unite c d)) &gt;
encodeToNat (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a b) (Unite c d)) &gt;
encodeToNat (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk15f"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList (Unite (Unite a b) (Unite c d))) &gt;
listToNat
  (encodeToList (Unite (Unite (Unite a b) c) d))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk160"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  ((encodeToList d ++ encodeToList c ++ [false]) ++
   (encodeToList b ++ encodeToList a ++ [false]) ++
   [false]) &gt;
listToNat
  (encodeToList d ++
   (encodeToList c ++
    (encodeToList b ++ encodeToList a ++ [false]) ++
    [false]) ++ [false])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk161"><span class="nb">rewrite</span> !app_assoc, !listToNatFalse, &lt;- !app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList d ++
   encodeToList c ++
   [false] ++ encodeToList b ++ encodeToList a) &gt;
listToNat
  (encodeToList d ++
   encodeToList c ++ encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk162"><span class="nb">apply</span> listToNatAppLt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat
  (encodeToList c ++ encodeToList b ++ encodeToList a) &lt;
listToNat
  (encodeToList c ++
   [false] ++ encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk163"><span class="nb">apply</span> listToNatAppLt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a) &lt;
listToNat
  ([false] ++ encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk164"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a) &lt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk165"><span class="nb">assert</span> (h : <span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk166" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk166"><hr></label><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a) &lt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk167">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk168"><span class="nb">pose proof</span> encodeToListFirstTrue b <span class="kr">as</span> [s1 h1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk169"><span class="nb">pose proof</span> encodeToListFirstTrue a <span class="kr">as</span> [s2 h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16a"><span class="nb">rewrite</span> h1, h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; listToNat ((true :: s1) ++ true :: s2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;
listToNat (s1 ++ true :: s2) +
(listToNat (s1 ++ true :: s2) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16c"><span class="nb">pose proof</span> listToNatAppFirst s1 (true :: s2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s2</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>listToNat (true :: s2)
‚â§ listToNat (s1 ++ true :: s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;
listToNat (s1 ++ true :: s2) +
(listToNat (s1 ++ true :: s2) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16d"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">simpl</span>; <span class="bp">lia</span>) : <span class="mi">0</span> &lt; listToNat (true :: s2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>encodeToList b = true :: s1</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToList a = true :: s2</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>listToNat (true :: s2)
‚â§ listToNat (s1 ++ true :: s2)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; listToNat (true :: s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;
listToNat (s1 ++ true :: s2) +
(listToNat (s1 ++ true :: s2) + <span class="mi">0</span>) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; listToNat (encodeToList b ++ encodeToList a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList b ++ encodeToList a) &lt;
listToNat (encodeToList b ++ encodeToList a) +
(listToNat (encodeToList b ++ encodeToList a) + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk16f"><span class="kn">Lemma</span> <span class="nf">rule2_replace_leafCount</span> (<span class="nv">a</span> : Tree) : leafCount a = leafCount (replaceRule2 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a = leafCount (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk170"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a = leafCount (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk171"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule2 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk172" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk172"><hr></label><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule2 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk173">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk174"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk175">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule2 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk176"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : leafCount (Unite a b) = leafCount a + leafCount b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b =
leafCount (replaceRule2 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk177"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b =
leafCount
  <span class="kr">match</span> a <span class="kr">with</span>
  | Unit =&gt; Unite (replaceRule2 a) (replaceRule2 b)
  | Unite _0 _1 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt;
          Unite (replaceRule2 a) (replaceRule2 b)
      | Unite _2 _3 =&gt;
          <span class="kr">if</span> leafCount _3 &lt;=? leafCount _0
          <span class="kr">then</span> Unite (Unite (Unite _0 _1) _2) _3
          <span class="kr">else</span> Unite (replaceRule2 a) (replaceRule2 b)
      <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk178">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b =
leafCount
  <span class="kr">match</span> a <span class="kr">with</span>
  | Unit =&gt; Unite (replaceRule2 a) (replaceRule2 b)
  | Unite _0 _1 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt;
          Unite (replaceRule2 a) (replaceRule2 b)
      | Unite _2 _3 =&gt;
          <span class="kr">if</span> leafCount _3 &lt;=? leafCount _0
          <span class="kr">then</span> Unite (Unite (Unite _0 _1) _2) _3
          <span class="kr">else</span> Unite (replaceRule2 a) (replaceRule2 b)
      <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk179"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b =
leafCount (Unite (replaceRule2 Unit) (replaceRule2 b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk17a"><hr></label><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount b =
leafCount
  <span class="kr">match</span> b <span class="kr">with</span>
  | Unit =&gt;
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 b)
  | Unite _0 _1 =&gt;
      <span class="kr">if</span> leafCount _1 &lt;=? leafCount a1
      <span class="kr">then</span> Unite (Unite (Unite a1 a2) _0) _1
      <span class="kr">else</span>
       Unite (replaceRule2 (Unite a1 a2))
         (replaceRule2 b)
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk17b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b =
leafCount (Unite (replaceRule2 Unit) (replaceRule2 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk17c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (leafCount b) = S (leafCount (replaceRule2 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk17d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount b =
leafCount
  <span class="kr">match</span> b <span class="kr">with</span>
  | Unit =&gt;
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 b)
  | Unite _0 _1 =&gt;
      <span class="kr">if</span> leafCount _1 &lt;=? leafCount a1
      <span class="kr">then</span> Unite (Unite (Unite a1 a2) _0) _1
      <span class="kr">else</span>
       Unite (replaceRule2 (Unite a1 a2))
         (replaceRule2 b)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk17e"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit =
leafCount
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk17f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule2 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk17f"><hr></label><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) =
leafCount
  (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk180">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit =
leafCount
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk181"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b), &lt;- !IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 + leafCount Unit =
leafCount (Unite a1 a2) +
leafCount (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk182"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 + <span class="mi">1</span> =
leafCount a1 + leafCount a2 + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk183">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) =
leafCount
  (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk184">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) =
leafCount
  (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (leafCount b2 &lt;=? leafCount a1); <span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b) <span class="kr">in</span> *; <span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk185"><span class="kn">Lemma</span> <span class="nf">rule2_replace_score</span> (<span class="nv">x</span> : Tree) : score x &lt;= score (replaceRule2 x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x ‚â§ score (replaceRule2 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk186"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x ‚â§ score (replaceRule2 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk187"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ score (replaceRule2 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk188" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ score (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk188"><hr></label><div class="goal-conclusion">score (Unite a b) ‚â§ score (replaceRule2 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk189">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ score (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ score (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) ‚â§ score (replaceRule2 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18c"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b)
‚â§ score (replaceRule2 (Unite Unit b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk18d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk18d"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) b)
‚â§ score (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b)
‚â§ score (replaceRule2 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk18f"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite Unit b) = Unite Unit (replaceRule2 b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b)
‚â§ score (Unite Unit (replaceRule2 b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk190"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b + score Unit + score b
‚â§ leafCount Unit + leafCount (replaceRule2 b) +
  score Unit + score (replaceRule2 b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk191"><span class="nb">rewrite</span> &lt;- !rule2_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b + score Unit + score b
‚â§ leafCount Unit + leafCount b + score Unit +
  score (replaceRule2 b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk192">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ score (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) b)
‚â§ score (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk193"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit)
‚â§ score (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk194" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk194"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk195">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit)
‚â§ score (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk196"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) Unit) = Unite (replaceRule2 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit)
‚â§ score (Unite (replaceRule2 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk197"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
score Unit
‚â§ leafCount (replaceRule2 (Unite a1 a2)) +
  leafCount Unit + score (replaceRule2 (Unite a1 a2)) +
  score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk198"><span class="nb">rewrite</span> &lt;- rule2_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score Unit ‚â§ score (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
score Unit
‚â§ leafCount (Unite a1 a2) + leafCount Unit +
  score (replaceRule2 (Unite a1 a2)) + score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk199">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19a"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> leafCount b2 &lt;=? leafCount a1 <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2 <span class="kr">else</span> Unite (replaceRule2 (Unite a1 a2)) (replaceRule2 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19b"><span class="nb">remember</span> (leafCount b2 &lt;=? leafCount a1) <span class="kr">as</span> val <span class="nb">eqn</span>:hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>val = (leafCount b2 &lt;=? leafCount a1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (<span class="kr">if</span> val
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19c"><span class="nb">symmetry in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (<span class="kr">if</span> val
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19d"><span class="nb">destruct</span> val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk19e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk19e"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk19f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a0"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount (Unite (Unite a1 a2) b1) + leafCount b2 +
  (leafCount (Unite a1 a2) + leafCount b1 +
   (leafCount a1 + leafCount a2 + score a1 + score a2) +
   score b1) + score b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a1"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount a1 + leafCount a2 + leafCount b1 +
  leafCount b2 +
  (leafCount a1 + leafCount a2 + leafCount b1 +
   (leafCount a1 + leafCount a2 + score a1 + score a2) +
   score b1) + score b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a2"><span class="nb">rewrite</span> Nat.leb_le <span class="kr">in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount b2 ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount a1 + leafCount a2 + leafCount b1 +
  leafCount b2 +
  (leafCount a1 + leafCount a2 + leafCount b1 +
   (leafCount a1 + leafCount a2 + score a1 + score a2) +
   score b1) + score b2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) ‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) ‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2))
‚â§ score
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a5"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2
‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount (replaceRule2 (Unite a1 a2)) +
  leafCount (replaceRule2 (Unite b1 b2)) +
  score (replaceRule2 (Unite a1 a2)) +
  score (replaceRule2 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a6"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2
‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount (replaceRule2 (Unite a1 a2)) +
  leafCount (replaceRule2 (Unite b1 b2)) +
  score (replaceRule2 (Unite a1 a2)) +
  score (replaceRule2 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a7"><span class="nb">rewrite</span> &lt;- !rule2_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2
‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
  score (replaceRule2 (Unite a1 a2)) +
  score (replaceRule2 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a8"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 + score a1 + score a2
‚â§ score (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 + score b1 + score b2
‚â§ score (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2)
‚â§ leafCount a1 + leafCount a2 +
  (leafCount b1 + leafCount b2) +
  score (replaceRule2 (Unite a1 a2)) +
  score (replaceRule2 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1a9"><span class="kn">Lemma</span> <span class="nf">rule2_replace&#39;</span> (<span class="nv">a</span> : Tree) : encodeToNat a &gt;= encodeToNat (replaceRule2 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a ‚â• encodeToNat (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1aa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a ‚â• encodeToNat (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ab"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â• encodeToNat (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1ac"><hr></label><div class="goal-conclusion">encodeToNat (Unite a b)
‚â• encodeToNat (replaceRule2 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ae"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit ‚â• encodeToNat Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1af">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat a ‚â• encodeToNat (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b)
‚â• encodeToNat (replaceRule2 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b0"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b)
‚â• encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1b1"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) b)
‚â• encodeToNat (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b)
‚â• encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b3"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b)
‚â• encodeToNat (Unite Unit (replaceRule2 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b4"><span class="nb">apply</span> encodeToNatSubtermLeq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (replaceRule2 b) ‚â§ encodeToNat b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1b5"><hr></label><div class="goal-conclusion">leafCount (replaceRule2 b) = leafCount b</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (replaceRule2 b) ‚â§ encodeToNat b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (replaceRule2 b) = leafCount b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule2_replace_leafCount.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat b ‚â• encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) b)
‚â• encodeToNat (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1b9"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit)
‚â• encodeToNat
    (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1ba"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1bb">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit)
‚â• encodeToNat
    (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1bc"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) Unit) = Unite (replaceRule2 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit)
‚â• encodeToNat
    (Unite (replaceRule2 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1bd"><span class="nb">apply</span> encodeToNatSubtermLeq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat Unit ‚â• encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (replaceRule2 (Unite a1 a2))
‚â§ encodeToNat (Unite a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1be">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1bf"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> Nat.leb (leafCount b2) (leafCount a1) <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2 <span class="kr">else</span> Unite (replaceRule2 (Unite a1 a2)) (replaceRule2 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c0"><span class="nb">remember</span> (leafCount b2 &lt;=? leafCount a1) <span class="kr">as</span> val <span class="nb">eqn</span>:hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>val = (leafCount b2 &lt;=? leafCount a1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (<span class="kr">if</span> val
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c1"><span class="nb">symmetry in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (<span class="kr">if</span> val
     <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
     <span class="kr">else</span>
      Unite (replaceRule2 (Unite a1 a2))
        (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c2"><span class="nb">destruct</span> val; <span class="nb">rewrite</span> <span class="nl">?Nat</span>.leb_le, <span class="nl">?Nat</span>.leb_gt <span class="kr">in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount b2 ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1c3"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount b2 ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c5"><span class="nb">pose proof</span> rule2_a1 a1 a2 b1 b2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount b2 ‚â§ leafCount a1</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c7"><span class="nb">pose proof</span> encodeToNatSubtermLeq1 _ (Unite b1 b2) _ IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (Unite b1 b2))
‚â§ encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c8"><span class="nb">pose proof</span> encodeToNatSubtermLeq2 _ (replaceRule2 (Unite a1 a2)) _ IHb <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule2_replace_leafCount).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) ‚â• encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite b1 b2) ‚â• encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (Unite b1 b2))
‚â§ encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))
‚â§ encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))
‚â• encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1c9"><span class="kn">Lemma</span> <span class="nf">rule2_replace</span> (<span class="nv">a</span> : Tree) (<span class="nv">h</span> : hasRule2 a) : encodeToNat a &gt; encodeToNat (replaceRule2 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a &gt; encodeToNat (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat a &gt; encodeToNat (replaceRule2 a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1cb"><span class="nb">induction</span> a <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1cc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 a ‚Üí encodeToNat a &gt; encodeToNat (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1cc"><hr></label><div class="goal-conclusion">encodeToNat (Unite a b) &gt;
encodeToNat (replaceRule2 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1cd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ce"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1cf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 a ‚Üí encodeToNat a &gt; encodeToNat (replaceRule2 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite a b) &gt;
encodeToNat (replaceRule2 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d0"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b) &gt;
encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1d1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1d1"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) b) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b) &gt;
encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d3"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b) &gt;
encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d4"><span class="nb">pose proof</span> IHb h <span class="kr">as</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b) &gt;
encodeToNat (replaceRule2 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d5"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite Unit b) = Unite Unit (replaceRule2 b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite Unit b) &gt;
encodeToNat (Unite Unit (replaceRule2 b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (encodeToNatSubtermLt2 _ Unit _ H <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule2_replace_leafCount)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 b ‚Üí encodeToNat b &gt; encodeToNat (replaceRule2 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) b) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d7"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1d8"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1d9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1da"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule2 (Unite (Unite a1 a2) Unit) = hasRule2 (Unite a1 a2)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1db"><span class="nb">pose proof</span> IHa h <span class="kr">as</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (replaceRule2 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1dc"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) Unit) = Unite (replaceRule2 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit ‚Üí encodeToNat Unit &gt; encodeToNat (replaceRule2 Unit)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>encodeToNat (Unite a1 a2) &gt;
encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) Unit) &gt;
encodeToNat (Unite (replaceRule2 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (encodeToNatSubtermLt1 _ Unit _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1dd">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1de"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule2 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> leafCount b2 &lt;=? leafCount a1 <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2 <span class="kr">else</span> Unite (replaceRule2 (Unite a1 a2)) (replaceRule2 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (<span class="kr">if</span> leafCount b2 &lt;=? leafCount a1
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1df"><span class="nb">remember</span> (leafCount b2 &lt;=? leafCount a1) <span class="kr">as</span> val <span class="nb">eqn</span>:hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>val = (leafCount b2 &lt;=? leafCount a1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e0"><span class="nb">symmetry in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite a1 a2) b1) b2
   <span class="kr">else</span>
    Unite (replaceRule2 (Unite a1 a2))
      (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e1"><span class="nb">destruct</span> val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1e2"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat (Unite (Unite (Unite a1 a2) b1) b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rule2_a1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e5"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) = (leafCount b2 &lt;=? leafCount a1) || hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1)
|| hasRule2 (Unite a1 a2)
|| hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e6"><span class="nb">rewrite</span> hIf <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || hasRule2 (Unite a1 a2)
|| hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e7"><span class="nb">rewrite</span> orb_false_l <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1e8"><span class="nb">destruct</span> (orb_prop_elim _ _ h) <span class="kr">as</span> [H | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1e9"><hr></label><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ea">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1eb"><span class="nb">pose proof</span> encodeToNatSubtermLt1 _ (Unite b1 b2) _ (IHa H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (Unite b1 b2)) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ec"><span class="nb">pose proof</span> encodeToNatSubtermLeq2 (replaceRule2 (Unite b1 b2)) (replaceRule2 (Unite a1 a2)) (Unite b1 b2) <span class="kp">ltac</span>:(<span class="nb">apply</span> rule2_replace&#39;) <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule2_replace_leafCount).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (Unite b1 b2)) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))
‚â§ encodeToNat
    (Unite (replaceRule2 (Unite a1 a2))
       (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ed">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ee">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ef"><span class="nb">pose proof</span> encodeToNatSubtermLt2 _ (Unite a1 a2) _ (IHb H) <span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- rule2_replace_leafCount).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite a1 a2)
     (replaceRule2 (Unite b1 b2))) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f0"><span class="nb">pose proof</span> encodeToNatSubtermLeq1 (replaceRule2 (Unite a1 a2)) (replaceRule2 (Unite b1 b2)) (Unite a1 a2) <span class="kp">ltac</span>:(<span class="nb">apply</span> rule2_replace&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2)
‚Üí encodeToNat (Unite a1 a2) &gt; encodeToNat (replaceRule2 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)
‚Üí encodeToNat (Unite b1 b2) &gt; encodeToNat (replaceRule2 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (Unite a1 a2)
     (replaceRule2 (Unite b1 b2))) &lt;
encodeToNat (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))
‚â§ encodeToNat
    (Unite (Unite a1 a2)
       (replaceRule2 (Unite b1 b2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat (Unite (Unite a1 a2) (Unite b1 b2)) &gt;
encodeToNat
  (Unite (replaceRule2 (Unite a1 a2))
     (replaceRule2 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f1"><span class="kn">Lemma</span> <span class="nf">rule2_b</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : totalUniteCount (Unite (Unite a b) (Unite c d)) = totalUniteCount (Unite (Unite (Unite a b) c) d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite (Unite a b) (Unite c d)) =
totalUniteCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite (Unite a b) (Unite c d)) =
totalUniteCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f3"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (S
     (totalUniteCount a + totalUniteCount b +
      S (totalUniteCount c + totalUniteCount d))) =
S
  (S
     (S
        (totalUniteCount a + totalUniteCount b +
         totalUniteCount c + totalUniteCount d)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f4"><span class="kn">Lemma</span> <span class="nf">rule2_c</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : leafCount (Unite (Unite a b) (Unite c d)) = leafCount (Unite (Unite (Unite a b) c) d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a b) (Unite c d)) =
leafCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a b) (Unite c d)) =
leafCount (Unite (Unite (Unite a b) c) d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b +
(leafCount c + leafCount d) =
leafCount a + leafCount b + leafCount c + leafCount d</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f7"><span class="kn">Lemma</span> <span class="nf">rewriteRule3</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) (<span class="nv">h</span> : leafCount a &lt; leafCount d) : score (Unite (Unite a b) (Unite c d)) &lt; score (Unite (Unite (Unite d c) b) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a &lt; leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a b) (Unite c d)) &lt;
score (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a &lt; leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a b) (Unite c d)) &lt;
score (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1f9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount a &lt; leafCount d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b +
(leafCount c + leafCount d) +
(leafCount a + leafCount b + score a + score b) +
(leafCount c + leafCount d + score c + score d) &lt;
leafCount d + leafCount c + leafCount b + leafCount a +
(leafCount d + leafCount c + leafCount b +
 (leafCount d + leafCount c + score d + score c) +
 score b) + score a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">hasRule3</span> (<span class="nv">x</span> : Tree) : bool :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; false
  | Unite a b =&gt;
    <span class="kr">match</span> a <span class="kr">with</span>
    | Unit =&gt; hasRule3 b
    | Unite a0 b0 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt; hasRule3 a
      | Unite c d =&gt;
        (leafCount a0 &lt;? leafCount d) || hasRule3 a || hasRule3 b
      <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">replaceRule3</span> (<span class="nv">x</span> : Tree) : Tree :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Unit =&gt; Unit
  | Unite a b =&gt;
    <span class="kr">match</span> a <span class="kr">with</span>
    | Unit =&gt; Unite (replaceRule3 a) (replaceRule3 b)
    | Unite a0 b0 =&gt;
      <span class="kr">match</span> b <span class="kr">with</span>
      | Unit =&gt; Unite (replaceRule3 a) (replaceRule3 b)
      | Unite c d =&gt;
        <span class="kr">if</span> leafCount a0 &lt;? leafCount d
        <span class="kr">then</span> Unite (Unite (Unite d c) b0) a0
        <span class="kr">else</span> Unite (replaceRule3 a) (replaceRule3 b)
      <span class="kr">end</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1fa"><span class="kn">Lemma</span> <span class="nf">rule3_replace_leafCount</span> (<span class="nv">x</span> : Tree) : leafCount x = leafCount (replaceRule3 x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount x = leafCount (replaceRule3 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1fb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount x = leafCount (replaceRule3 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1fc"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule3 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk1fd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule3 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk1fd"><hr></label><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule3 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1fe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = leafCount (replaceRule3 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk1ff"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk200">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a = leafCount (replaceRule3 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a b) =
leafCount (replaceRule3 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk201"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit b) =
leafCount (replaceRule3 (Unite Unit b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk202" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk202"><hr></label><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) b) =
leafCount (replaceRule3 (Unite (Unite a1 a2) b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk203">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit b) =
leafCount (replaceRule3 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk204"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit Unit) =
leafCount (replaceRule3 (Unite Unit Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk205" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk205"><hr></label><div class="goal-conclusion">leafCount (Unite Unit (Unite b1 b2)) =
leafCount (replaceRule3 (Unite Unit (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk206">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit Unit) =
leafCount (replaceRule3 (Unite Unit Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk207"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk208">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (Unite b1 b2)) =
leafCount (replaceRule3 (Unite Unit (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk209"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite Unit (Unite b1 b2)) = Unite Unit (replaceRule3 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite Unit (Unite b1 b2)) =
leafCount (Unite Unit (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20a"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span>, leafCount (Unite Unit x) = <span class="mi">1</span> + leafCount x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + leafCount (Unite b1 b2) =
<span class="mi">1</span> + leafCount (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b = leafCount (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) b) =
leafCount (replaceRule3 (Unite (Unite a1 a2) b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20c"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) Unit) =
leafCount (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk20d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk20d"><hr></label><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) Unit) =
leafCount (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk20f"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) Unit) = Unite (replaceRule3 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) Unit) =
leafCount (Unite (replaceRule3 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk210"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span>, leafCount (Unite x Unit) = leafCount x + <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount Unit = leafCount (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + <span class="mi">1</span> =
leafCount (replaceRule3 (Unite a1 a2)) + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk211">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk212"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> leafCount a1 &lt;? leafCount b2 <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1 <span class="kr">else</span> Unite (replaceRule3 (Unite a1 a2)) (replaceRule3 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (<span class="kr">if</span> leafCount a1 &lt;? leafCount b2
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk213"><span class="nb">remember</span> (leafCount a1 &lt;? leafCount b2) <span class="kr">as</span> val <span class="nb">eqn</span>:hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>val = (leafCount a1 &lt;? leafCount b2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk214"><span class="nb">symmetry in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk215"><span class="nb">destruct</span> val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk216" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk216"><hr></label><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk217">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk218"><span class="nb">rewrite</span> Nat.ltb_lt <span class="kr">in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk219"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) =
leafCount b2 + leafCount b1 + leafCount a2 +
leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount (Unite a1 a2) = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount (Unite b1 b2) = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a1 a2) (Unite b1 b2)) =
leafCount
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21b"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>leafCount a1 + leafCount a2 = leafCount (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>leafCount b1 + leafCount b2 = leafCount (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) =
leafCount (replaceRule3 (Unite a1 a2)) +
leafCount (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21c"><span class="kn">Lemma</span> <span class="nf">rule3_replace_identity</span> (<span class="nv">x</span> : Tree) (<span class="nv">h</span> : hasRule3 x = false) : replaceRule3 x = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk21e"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 Unit = Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk21f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 a = false ‚Üí replaceRule3 a = a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk21f"><hr></label><div class="goal-conclusion">replaceRule3 (Unite a b) = Unite a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk220">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 Unit = Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk221">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 a = false ‚Üí replaceRule3 a = a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite a b) = Unite a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk222"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite Unit b) = Unite Unit b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk223" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk223"><hr></label><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) b) =
Unite (Unite a1 a2) b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk224">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite Unit b) = Unite Unit b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk225"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite Unit b) = Unite Unit (replaceRule3 b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit (replaceRule3 b) = Unite Unit b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk226"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite Unit b) = hasRule3 b) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit (replaceRule3 b) = Unite Unit b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk227"><span class="nb">rewrite</span> (IHb h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit b = Unite Unit b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk228">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b = false ‚Üí replaceRule3 b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) b) =
Unite (Unite a1 a2) b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk229"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) Unit) =
Unite (Unite a1 a2) Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk22a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk22a"><hr></label><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk22b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) Unit) =
Unite (Unite a1 a2) Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk22c"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) Unit) = Unite (replaceRule3 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (replaceRule3 (Unite a1 a2)) Unit =
Unite (Unite a1 a2) Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk22d"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) Unit) = hasRule3 (Unite a1 a2)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (replaceRule3 (Unite a1 a2)) Unit =
Unite (Unite a1 a2) Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk22e"><span class="nb">rewrite</span> (IHa h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false ‚Üí replaceRule3 Unit = Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit = Unite (Unite a1 a2) Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk22f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk230"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = (leafCount a1 &lt;? leafCount b2) || hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2)
|| hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk231"><span class="nb">rewrite</span> !orb_false_iff <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>((leafCount a1 &lt;? leafCount b2) = false
 ‚àß hasRule3 (Unite a1 a2) = false)
‚àß hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk232"><span class="nb">destruct</span> h <span class="kr">as</span> [[h3 h1] h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk233"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> leafCount a1 &lt;? leafCount b2 <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1 <span class="kr">else</span> Unite (replaceRule3 (Unite a1 a2)) (replaceRule3 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> leafCount a1 &lt;? leafCount b2
 <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
 <span class="kr">else</span>
  Unite (replaceRule3 (Unite a1 a2))
    (replaceRule3 (Unite b1 b2))) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk234"><span class="nb">rewrite</span> h3, (IHa h1), (IHb h2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false ‚Üí replaceRule3 (Unite a1 a2) = Unite a1 a2</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false ‚Üí replaceRule3 (Unite b1 b2) = Unite b1 b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
Unite (Unite a1 a2) (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk235"><span class="kn">Lemma</span> <span class="nf">rule3_replace_score</span> (<span class="nv">x</span> : Tree) (<span class="nv">h</span> : hasRule3 x) : score x &lt; score (replaceRule3 x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x &lt; score (replaceRule3 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk236"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x &lt; score (replaceRule3 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk237"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit &lt; score (replaceRule3 Unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk238" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 a ‚Üí score a &lt; score (replaceRule3 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk238"><hr></label><div class="goal-conclusion">score (Unite a b) &lt; score (replaceRule3 (Unite a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk239">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit &lt; score (replaceRule3 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23a"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit &lt; score (replaceRule3 Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 a ‚Üí score a &lt; score (replaceRule3 a)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) &lt; score (replaceRule3 (Unite a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23c"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b) &lt;
score (replaceRule3 (Unite Unit b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk23d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk23d"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) b) &lt;
score (replaceRule3 (Unite (Unite a1 a2) b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b) &lt;
score (replaceRule3 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk23f"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite Unit b) = hasRule3 b) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b) &lt;
score (replaceRule3 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk240"><span class="nb">pose proof</span> IHb h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b) &lt;
score (replaceRule3 (Unite Unit b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk241"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite Unit b) = Unite Unit (replaceRule3 b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite Unit b) &lt;
score (Unite Unit (replaceRule3 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk242"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, score (Unite x y) = leafCount x + leafCount y + score x + score y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b + score Unit + score b &lt;
leafCount Unit + leafCount (replaceRule3 b) +
score Unit + score (replaceRule3 b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk243"><span class="nb">rewrite</span> &lt;- !rule3_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 b</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit + leafCount b + score Unit + score b &lt;
leafCount Unit + leafCount b + score Unit +
score (replaceRule3 b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk244">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 b ‚Üí score b &lt; score (replaceRule3 b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) b) &lt;
score (replaceRule3 (Unite (Unite a1 a2) b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk245"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) &lt;
score (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk246" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk246"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk247">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) &lt;
score (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk248"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) Unit) = hasRule3 (Unite a1 a2)) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) &lt;
score (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk249"><span class="nb">pose proof</span> IHa h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) &lt;
score (replaceRule3 (Unite (Unite a1 a2) Unit))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24a"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) Unit) = Unite (replaceRule3 (Unite a1 a2)) Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) Unit) &lt;
score (Unite (replaceRule3 (Unite a1 a2)) Unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24b"><span class="nb">rewrite</span> !((<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, score (Unite x y) = leafCount x + leafCount y + score x + score y) _ Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit +
score (Unite a1 a2) + score Unit &lt;
leafCount (replaceRule3 (Unite a1 a2)) +
leafCount Unit + score (replaceRule3 (Unite a1 a2)) +
score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24c"><span class="nb">rewrite</span> &lt;- ! rule3_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit ‚Üí score Unit &lt; score (replaceRule3 Unit)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount Unit +
score (Unite a1 a2) + score Unit &lt;
leafCount (Unite a1 a2) + leafCount Unit +
score (replaceRule3 (Unite a1 a2)) + score Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24e"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : replaceRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = <span class="kr">if</span> leafCount a1 &lt;? leafCount b2 <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1 <span class="kr">else</span> Unite (replaceRule3 (Unite a1 a2)) (replaceRule3 (Unite b1 b2))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2))</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (<span class="kr">if</span> leafCount a1 &lt;? leafCount b2
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk24f"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = (leafCount a1 &lt;? leafCount b2) || hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2)
|| hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (<span class="kr">if</span> leafCount a1 &lt;? leafCount b2
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk250"><span class="nb">remember</span> (leafCount a1 &lt;? leafCount b2) <span class="kr">as</span> val <span class="nb">eqn</span>:hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>val = (leafCount a1 &lt;? leafCount b2)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>val || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk251"><span class="nb">symmetry in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = val</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>val || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (<span class="kr">if</span> val
   <span class="kr">then</span> Unite (Unite (Unite b2 b1) a2) a1
   <span class="kr">else</span>
    Unite (replaceRule3 (Unite a1 a2))
      (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk252"><span class="nb">destruct</span> val.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk253" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk253"><hr></label><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk254">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk255"><span class="nb">rewrite</span> Nat.ltb_lt <span class="kr">in</span> hIf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score (Unite (Unite (Unite b2 b1) a2) a1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk256"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, score (Unite a b) = leafCount a + leafCount b + score a + score b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2) &lt;
leafCount (Unite (Unite b2 b1) a2) + leafCount a1 +
(leafCount (Unite b2 b1) + leafCount a2 +
 (leafCount b2 + leafCount b1 + score b2 + score b1) +
 score a2) + score a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk257"><span class="nb">rewrite</span> !(<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, leafCount (Unite a b) = leafCount a + leafCount b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 + leafCount a2 +
(leafCount b1 + leafCount b2) +
(leafCount a1 + leafCount a2 + score a1 + score a2) +
(leafCount b1 + leafCount b2 + score b1 + score b2) &lt;
leafCount b2 + leafCount b1 + leafCount a2 +
leafCount a1 +
(leafCount b2 + leafCount b1 + leafCount a2 +
 (leafCount b2 + leafCount b1 + score b2 + score b1) +
 score a2) + score a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk258">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk259"><span class="nb">rewrite</span> orb_false_l <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite (Unite a1 a2) (Unite b1 b2)) &lt;
score
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25a"><span class="nb">rewrite</span> !((<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, score (Unite x y) = leafCount x + leafCount y + score x + score y) _ (Unite _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
score
  (Unite (replaceRule3 (Unite a1 a2))
     (replaceRule3 (Unite b1 b2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25b"><span class="nb">rewrite</span> !((<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, score (Unite x y) = leafCount x + leafCount y + score x + score y) _ (replaceRule3 _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (replaceRule3 (Unite a1 a2)) +
leafCount (replaceRule3 (Unite b1 b2)) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25c"><span class="nb">rewrite</span> &lt;- !rule3_replace_leafCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2)
‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25d"><span class="nb">remember</span> (hasRule3 (Unite a1 a2)) <span class="kr">as</span> val <span class="nb">eqn</span>:hL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>val = hasRule3 (Unite a1 a2)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>val || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>val ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25e"><span class="nb">symmetry in</span> hL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = val</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>val || hasRule3 (Unite b1 b2)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>val ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2)
‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk25f"><span class="nb">destruct</span> val; <span class="nb">remember</span> (hasRule3 (Unite b1 b2)) <span class="kr">as</span> val <span class="nb">eqn</span>:hR; <span class="nb">symmetry in</span> hR; <span class="nb">destruct</span> val; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> h; <span class="bp">lia</span>); <span class="kp">try</span> <span class="nb">pose proof</span> IHa <span class="kp">ltac</span>:(<span class="bp">easy</span>); <span class="kp">try</span> <span class="nb">pose proof</span> IHb <span class="kp">ltac</span>:(<span class="bp">easy</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk260" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk260"><hr></label><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk261" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk261"><hr></label><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk262">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk263">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk264" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk264"><hr></label><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk265">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk266"><span class="nb">rewrite</span> (rule3_replace_identity _ hR).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk267"><span class="nb">pose proof</span> IHa <span class="kp">ltac</span>:(<span class="nb">trivial</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = true</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0, _1</var><span class="hyp-type"><b>: </b><span>score (Unite a1 a2) &lt;
score (replaceRule3 (Unite a1 a2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (Unite b1 b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk268">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (replaceRule3 (Unite a1 a2)) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk269"><span class="nb">rewrite</span> (rule3_replace_identity _ hL).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = true</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>false ‚Üí score (Unite a1 a2) &lt; score (replaceRule3 (Unite a1 a2))</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>true ‚Üí score (Unite b1 b2) &lt; score (replaceRule3 (Unite b1 b2))</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score (Unite b1 b2) &lt;
score (replaceRule3 (Unite b1 b2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) + score (Unite b1 b2) &lt;
leafCount (Unite a1 a2) + leafCount (Unite b1 b2) +
score (Unite a1 a2) +
score (replaceRule3 (Unite b1 b2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26a"><span class="kn">Lemma</span> <span class="nf">rule3_b</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : totalUniteCount (Unite (Unite a b) (Unite c d)) = totalUniteCount (Unite (Unite (Unite d c) b) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite (Unite a b) (Unite c d)) =
totalUniteCount (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">totalUniteCount (Unite (Unite a b) (Unite c d)) =
totalUniteCount (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (S
     (totalUniteCount a + totalUniteCount b +
      S (totalUniteCount c + totalUniteCount d))) =
S
  (S
     (S
        (totalUniteCount d + totalUniteCount c +
         totalUniteCount b + totalUniteCount a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26d"><span class="kn">Lemma</span> <span class="nf">rule3_c</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Tree) : leafCount (Unite (Unite a b) (Unite c d)) = leafCount (Unite (Unite (Unite d c) b) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a b) (Unite c d)) =
leafCount (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite (Unite a b) (Unite c d)) =
leafCount (Unite (Unite (Unite d c) b) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk26f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c, d</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b +
(leafCount c + leafCount d) =
leafCount d + leafCount c + leafCount b + leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk270"><span class="kn">Lemma</span> <span class="nf">scoreUpperBound</span> (<span class="nv">x</span> : Tree) : score x &lt;= (leafCount x) * (leafCount x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x ‚â§ leafCount x * leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk271"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x ‚â§ leafCount x * leafCount x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk272"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ leafCount Unit * leafCount Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk273" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk273"><hr></label><div class="goal-conclusion">score (Unite a b)
‚â§ leafCount (Unite a b) * leafCount (Unite a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk274">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ leafCount Unit * leafCount Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk275"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk276">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b)
‚â§ leafCount (Unite a b) * leafCount (Unite a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk277"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk278"><span class="nb">pose proof</span> oneLeqLeafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk279"><span class="nb">pose proof</span> oneLeqLeafCount b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27a"><span class="nb">assert</span> (h : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, <span class="mi">1</span> &lt;= a -&gt; <span class="mi">1</span> &lt;= b -&gt; a * a + b * b + a + b &lt;= (a + b) * (a + b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : nat,
  <span class="mi">1</span> ‚â§ _0
  ‚Üí <span class="mi">1</span> ‚â§ _1
    ‚Üí _0 * _0 + _1 * _1 + _0 + _1
      ‚â§ (_0 + _1) * (_0 + _1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk27b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : nat,
  <span class="mi">1</span> ‚â§ _0
  ‚Üí <span class="mi">1</span> ‚â§ _1
    ‚Üí _0 * _0 + _1 * _1 + _0 + _1
      ‚â§ (_0 + _1) * (_0 + _1)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk27b"><hr></label><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : nat,
  <span class="mi">1</span> ‚â§ _0
  ‚Üí <span class="mi">1</span> ‚â§ _1
    ‚Üí _0 * _0 + _1 * _1 + _0 + _1
      ‚â§ (_0 + _1) * (_0 + _1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27d"><span class="nb">intros</span> x y hx hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x + y * y + x + y ‚â§ (x + y) * (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27e"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : (x + y) * (x + y) = x * x + <span class="mi">2</span> * x * y + y * y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x + y * y + x + y ‚â§ x * x + <span class="mi">2</span> * x * y + y * y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk27f"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">intros</span>; <span class="bp">lia</span>) : x + y &lt;= <span class="mi">2</span> * x * y -&gt; x * x + y * y + x + y &lt;= x * x + <span class="mi">2</span> * x * y + y * y) <span class="kr">as</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ y</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>x + y ‚â§ <span class="mi">2</span> * x * y
‚Üí x * x + y * y + x + y
  ‚â§ x * x + <span class="mi">2</span> * x * y + y * y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * x + y * y + x + y ‚â§ x * x + <span class="mi">2</span> * x * y + y * y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk280"><span class="nb">apply</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ y</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>x + y ‚â§ <span class="mi">2</span> * x * y
‚Üí x * x + y * y + x + y
  ‚â§ x * x + <span class="mi">2</span> * x * y + y * y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + y ‚â§ <span class="mi">2</span> * x * y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk281"><span class="nb">clear</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + y ‚â§ <span class="mi">2</span> * x * y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk282">zify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x + Z.of_nat y ‚â§ <span class="mi">2</span> * Z.of_nat x * Z.of_nat y)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk283"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">intros</span>; <span class="bp">lia</span>) : ((Z.of_nat x * Z.of_nat y - Z.of_nat x) + (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z -&gt; (Z.of_nat x + Z.of_nat y ‚â§ <span class="mi">2</span> * Z.of_nat x * Z.of_nat y)%Z) <span class="kr">as</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z
‚Üí (Z.of_nat x + Z.of_nat y
   ‚â§ <span class="mi">2</span> * Z.of_nat x * Z.of_nat y)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x + Z.of_nat y ‚â§ <span class="mi">2</span> * Z.of_nat x * Z.of_nat y)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk284"><span class="nb">apply</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span>(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z
‚Üí (Z.of_nat x + Z.of_nat y
   ‚â§ <span class="mi">2</span> * Z.of_nat x * Z.of_nat y)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk285"><span class="nb">clear</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk286"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">intros</span>; <span class="bp">lia</span>) : <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Z), (a * b - b = (a - <span class="mi">1</span>) * b)%Z) <span class="kr">as</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z, (_0 * _1 - _1)%Z = ((_0 - <span class="mi">1</span>) * _1)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x * Z.of_nat y - Z.of_nat y) &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk287"><span class="nb">rewrite</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z, (_0 * _1 - _1)%Z = ((_0 - <span class="mi">1</span>) * _1)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk288"><span class="nb">clear</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk289"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">intros</span>; <span class="bp">lia</span>) : <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Z), (a * b - a = (b - <span class="mi">1</span>) * a)%Z) <span class="kr">as</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z, (_0 * _1 - _0)%Z = ((_1 - <span class="mi">1</span>) * _0)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.of_nat x * Z.of_nat y - Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28a"><span class="nb">rewrite</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>hi</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z, (_0 * _1 - _0)%Z = ((_1 - <span class="mi">1</span>) * _0)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28b"><span class="nb">clear</span> hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28c"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="nb">intros</span>; <span class="bp">lia</span>) : <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Z), (<span class="mi">0</span> &lt;= a)%Z -&gt; (<span class="mi">0</span> &lt;= b)%Z -&gt; (<span class="mi">0</span> &lt;= a * b)%Z) <span class="kr">as</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z,
  (<span class="mi">0</span> ‚â§ _0)%Z ‚Üí (<span class="mi">0</span> ‚â§ _1)%Z ‚Üí (<span class="mi">0</span> ‚â§ _0 * _1)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28d"><span class="nb">pose proof</span> h ((Z.of_nat y - <span class="mi">1</span>)%Z) (Z.of_nat x) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z,
  (<span class="mi">0</span> ‚â§ _0)%Z ‚Üí (<span class="mi">0</span> ‚â§ _1)%Z ‚Üí (<span class="mi">0</span> ‚â§ _0 * _1)%Z</span></span></span><br><span><var>_8</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ (Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28e"><span class="nb">pose proof</span> h ((Z.of_nat x - <span class="mi">1</span>)%Z) (Z.of_nat y) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score b) ‚â§ Z.of_nat (leafCount b) * Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>(Z.of_nat (score a) ‚â§ Z.of_nat (leafCount a) * Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score a))%Z</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat y)%Z</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount b))%Z</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (leafCount a))%Z</span></span></span><br><span><var>_6</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat (score b))%Z</span></span></span><br><span><var>_7</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ Z.of_nat x)%Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : Z,
  (<span class="mi">0</span> ‚â§ _0)%Z ‚Üí (<span class="mi">0</span> ‚â§ _1)%Z ‚Üí (<span class="mi">0</span> ‚â§ _0 * _1)%Z</span></span></span><br><span><var>_8</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ (Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x)%Z</span></span></span><br><span><var>_9</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> ‚â§ (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.of_nat y - <span class="mi">1</span>) * Z.of_nat x +
 (Z.of_nat x - <span class="mi">1</span>) * Z.of_nat y &gt;= <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk28f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : nat,
  <span class="mi">1</span> ‚â§ _0
  ‚Üí <span class="mi">1</span> ‚â§ _1
    ‚Üí _0 * _0 + _1 * _1 + _0 + _1
      ‚â§ (_0 + _1) * (_0 + _1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk290"><span class="nb">pose proof</span> h (leafCount a) (leafCount b) <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>score a ‚â§ leafCount a * leafCount a</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>score b ‚â§ leafCount b * leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> <span class="nv">_1</span> : nat,
  <span class="mi">1</span> ‚â§ _0
  ‚Üí <span class="mi">1</span> ‚â§ _1
    ‚Üí _0 * _0 + _1 * _1 + _0 + _1
      ‚â§ (_0 + _1) * (_0 + _1)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>leafCount a * leafCount a +
leafCount b * leafCount b + leafCount a +
leafCount b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b + score a + score b
‚â§ (leafCount a + leafCount b) *
  (leafCount a + leafCount b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">constructTree</span> (<span class="nv">n</span> : nat) : Tree :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; Unit
  | S n =&gt; Unite (constructTree n) Unit
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk291"><span class="kn">Lemma</span> <span class="nf">constructTreeSize</span> (<span class="nv">n</span> : nat) : leafCount (constructTree n) = S n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree n) = S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk292"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree n) = S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk293"><span class="nb">induction</span> n <span class="kr">as</span> [| n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree <span class="mi">0</span>) = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk294" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk294"><hr></label><div class="goal-conclusion">leafCount (constructTree (S n)) = S (S n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk295">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree <span class="mi">0</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk296">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree (S n)) = S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk297"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (constructTree n) + <span class="mi">1</span> = S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk298"><span class="kn">Lemma</span> <span class="nf">constructTreeScore</span> (<span class="nv">n</span> : nat) : score (constructTree n) = (n + <span class="mi">1</span>) * (n + <span class="mi">2</span>) / <span class="mi">2</span> - <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk299"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk29a"><span class="nb">induction</span> n <span class="kr">as</span> [| n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score (constructTree <span class="mi">0</span>) =
((<span class="mi">0</span> + <span class="mi">1</span>) * (<span class="mi">0</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk29b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk29b"><hr></label><div class="goal-conclusion">score (constructTree (S n)) =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk29c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">score (constructTree <span class="mi">0</span>) =
((<span class="mi">0</span> + <span class="mi">1</span>) * (<span class="mi">0</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk29d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (constructTree (S n)) =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk29e"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="nb">simpl</span>; <span class="bp">reflexivity</span>) : score (constructTree (S n)) = _), constructTreeSize, IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk29f"><span class="nb">destruct</span> (Nat.Even_or_Odd n) <span class="kr">as</span> [s | s].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Nat.Even n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Nat.Odd n</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2a0"><hr></label><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Nat.Even n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a2"><span class="nb">destruct</span> s <span class="kr">as</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">2</span> * a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a3"><span class="nb">subst</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a)) =
((<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a) + <span class="mi">1</span> +
(((<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S (<span class="mi">2</span> * a) + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a) + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a4"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : (<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>) = ((<span class="mi">2</span> * a + <span class="mi">1</span>) * (a + <span class="mi">1</span>)) * <span class="mi">2</span>), (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : (S (<span class="mi">2</span> * a) + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a) + <span class="mi">2</span>) = ((a + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a) + <span class="mi">2</span>)) * <span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a)) =
((<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a) + <span class="mi">1</span> +
(((<span class="mi">2</span> * a + <span class="mi">1</span>) * (a + <span class="mi">1</span>) * <span class="mi">2</span>) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((a + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a) + <span class="mi">2</span>) * <span class="mi">2</span>) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a5"><span class="nb">rewrite</span> !Nat.div_mul; <span class="kp">try</span> <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a)) =
((<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a) + <span class="mi">1</span> + ((<span class="mi">2</span> * a + <span class="mi">1</span>) * (a + <span class="mi">1</span>) - <span class="mi">1</span>) + <span class="mi">0</span> =
(a + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a) + <span class="mi">2</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a6"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : <span class="kr">forall</span> <span class="nv">a</span>, S a = a + <span class="mi">1</span>), !Nat.mul_add_distr_r, !Nat.mul_add_distr_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a)) =
((<span class="mi">2</span> * a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span> +
(<span class="mi">2</span> * a * a + <span class="mi">2</span> * a * <span class="mi">1</span> + (<span class="mi">1</span> * a + <span class="mi">1</span> * <span class="mi">1</span>) - <span class="mi">1</span>) + <span class="mi">0</span> =
a * (<span class="mi">2</span> * a) + a * <span class="mi">1</span> + a * <span class="mi">2</span> +
(<span class="mi">1</span> * (<span class="mi">2</span> * a) + <span class="mi">1</span> * <span class="mi">1</span> + <span class="mi">1</span> * <span class="mi">2</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Nat.Odd n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a8"><span class="nb">destruct</span> s <span class="kr">as</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree n) =
((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">2</span> * a + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n + <span class="mi">1</span> + (((n + <span class="mi">1</span>) * (n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S n + <span class="mi">1</span>) * (S n + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2a9"><span class="nb">subst</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a + <span class="mi">1</span>)) =
((<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span> +
(((<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">2</span>)) `div` <span class="mi">2</span> -
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2aa"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>) = ((a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) * <span class="mi">2</span>), (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : (S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span>) * (S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">2</span>) = ((S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span>) * (a + <span class="mi">2</span>)) * <span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a + <span class="mi">1</span>)) =
((<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span> +
(((a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>) * <span class="mi">2</span>) `div` <span class="mi">2</span> - <span class="mi">1</span>) + <span class="mi">0</span> =
((S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span>) * (a + <span class="mi">2</span>) * <span class="mi">2</span>) `div` <span class="mi">2</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ab"><span class="nb">rewrite</span> !Nat.div_mul; <span class="kp">try</span> <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a + <span class="mi">1</span>)) =
((<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span> + ((a + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>) - <span class="mi">1</span>) +
<span class="mi">0</span> = (S (<span class="mi">2</span> * a + <span class="mi">1</span>) + <span class="mi">1</span>) * (a + <span class="mi">2</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ac"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : <span class="kr">forall</span> <span class="nv">a</span>, S a = a + <span class="mi">1</span>), !Nat.mul_add_distr_r, !Nat.mul_add_distr_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>score (constructTree (<span class="mi">2</span> * a + <span class="mi">1</span>)) =
((<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span>) * (<span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">2</span>)) `div` <span class="mi">2</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * a + <span class="mi">1</span> + <span class="mi">1</span> + <span class="mi">1</span> +
(a * (<span class="mi">2</span> * a) + a * <span class="mi">1</span> + a * <span class="mi">2</span> +
 (<span class="mi">1</span> * (<span class="mi">2</span> * a) + <span class="mi">1</span> * <span class="mi">1</span> + <span class="mi">1</span> * <span class="mi">2</span>) - <span class="mi">1</span>) + <span class="mi">0</span> =
<span class="mi">2</span> * a * a + <span class="mi">2</span> * a * <span class="mi">2</span> + (<span class="mi">1</span> * a + <span class="mi">1</span> * <span class="mi">2</span>) +
(<span class="mi">1</span> * a + <span class="mi">1</span> * <span class="mi">2</span>) + (<span class="mi">1</span> * a + <span class="mi">1</span> * <span class="mi">2</span>) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">generateProduct</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : list A) (<span class="nv">b</span> : list B) : list (A * B) :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | [] =&gt; []
  | head :: tail =&gt; map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (head, x)) b ++ generateProduct tail b
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ad"><span class="kn">Lemma</span> <span class="nf">inProductList</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : list A) (<span class="nv">b</span> : list B) (<span class="nv">elementA</span> : A) (<span class="nv">hA</span> : In elementA a) (<span class="nv">elementB</span> : B) (<span class="nv">hB</span> : In elementB b) : In (elementA, elementB) (generateProduct a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA a</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA a</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2af"><span class="nb">induction</span> a <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA []</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct [] b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2b0"><hr></label><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA []</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct [] b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b2"><span class="nb">simpl</span> <span class="kr">in</span> hA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct [] b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b3"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b5"><span class="nb">destruct</span> hA <span class="kr">as</span> [hL | hR].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>head = elementA</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2b6"><hr></label><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>head = elementA</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b8"><span class="nb">subst</span> head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (elementA :: tail) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2b9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) b ++
   generateProduct tail b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ba"><span class="nb">apply</span> in_or_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) b)
‚à® In (elementA, elementB) (generateProduct tail b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2bb"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2bc"><span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2bd"><span class="nb">induction</span> b <span class="kr">as</span> [| head1 tail1 IH1]; [(<span class="nb">simpl</span> <span class="kr">in</span> hB); <span class="nb">exfalso</span>; <span class="bp">exact</span> hB |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB (head1 :: tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) (head1 :: tail1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2be"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB (head1 :: tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2bf"><span class="nb">destruct</span> hB <span class="kr">as</span> [h1 | h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2c0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2c0"><hr></label><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c2"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c3"><span class="nb">rewrite</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, elementB) = (elementA, elementB)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(elementA, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c5"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In elementB tail1
‚Üí In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IH1 h2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (generateProduct (head :: tail) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c7"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b ++
   generateProduct tail b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c8"><span class="nb">apply</span> in_or_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b)
‚à® In (elementA, elementB) (generateProduct tail b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2c9"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hR</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In elementA tail
‚Üí In (elementA, elementB)
    (generateProduct tail b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (elementA, elementB) (generateProduct tail b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IH hR).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ca"><span class="kn">Lemma</span> <span class="nf">inProductList2</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : list A) (<span class="nv">b</span> : list B) (<span class="nv">elementA</span> : A) (<span class="nv">elementB</span> : B) (<span class="nv">h</span> : In (elementA, elementB) (generateProduct a b)) : In elementA a /\ In elementB b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA a ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2cb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA a ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2cc"><span class="nb">induction</span> a <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct [] b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA [] ‚àß In elementB b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (generateProduct (head :: tail) b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2cd"><hr></label><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct [] b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA [] ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2cf"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA [] ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d0"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (generateProduct (head :: tail) b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d2"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b ++
   generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d3"><span class="nb">rewrite</span> in_app_iff <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b)
‚à® In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d4"><span class="nb">destruct</span> h <span class="kr">as</span> [h | h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2d5"><hr></label><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d7"><span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2d8"><span class="nb">induction</span> b <span class="kr">as</span> [| head1 tail1 IH1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) (head1 :: tail1))</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2d9"><hr></label><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2da" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2da">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2db"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2dc"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2dd">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) (head1 :: tail1))</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2de"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(head, head1) = (elementA, elementB)
‚à® In (elementA, elementB)
    (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2df"><span class="nb">destruct</span> h <span class="kr">as</span> [h | h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(head, head1) = (elementA, elementB)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2e0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2e0"><hr></label><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(head, head1) = (elementA, elementB)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e2"><span class="nb">rewrite</span> pair_eq <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>head = elementA ‚àß head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e3"><span class="nb">destruct</span> h <span class="kr">as</span> [hA hB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>head = elementA</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e4"><span class="nb">subst</span> head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>head1 = elementB</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)
‚Üí In elementA (elementA :: tail)
  ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (elementA :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e5"><span class="nb">subst</span> head1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (elementA, _0)) tail1)
‚Üí In elementA (elementA :: tail)
  ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (elementA :: tail)
‚àß In elementB (elementB :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">simpl</span>; <span class="nb">left</span>; <span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e7"><span class="nb">pose proof</span> IH1 h <span class="kr">as</span> [hA hB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)
‚àß In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2e8"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2e9"><hr></label><div class="goal-conclusion">In elementB (head1 :: tail1)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ea">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2eb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2eb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementB (head1 :: tail1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ec"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head1 = elementB ‚à® In elementB tail1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ed"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>head1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>tail1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB)
  (map (<span class="kr">Œª</span> <span class="nv">_0</span> : B, (head, _0)) tail1)
‚Üí In elementA (head :: tail) ‚àß In elementB tail1</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA (head :: tail)</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB tail1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementB tail1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ee">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ef"><span class="nb">pose proof</span> IH h <span class="kr">as</span> [hA hB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail) ‚àß In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f0"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2f1"><hr></label><div class="goal-conclusion">In elementB b</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA (head :: tail)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f3"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head = elementA ‚à® In elementA tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f4"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementA tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>elementA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>elementB</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In (elementA, elementB) (generateProduct tail b)
‚Üí In elementA tail ‚àß In elementB b</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>In elementA tail</span></span></span><br><span><var>hB</var><span class="hyp-type"><b>: </b><span>In elementB b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In elementB b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f6"><span class="kn">Lemma</span> <span class="nf">enumerateTrees</span> (<span class="nv">n</span> : nat) : { x : list Tree | <span class="kr">forall</span> <span class="nv">tree</span> : Tree, leafCount tree = n &lt;-&gt; In tree x }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f8"><span class="nb">induction</span> (lt_wf n) <span class="kr">as</span> [n _ IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2f9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2fa"><span class="nb">destruct</span> (decide (n = <span class="mi">0</span>)) <span class="kr">as</span> [h | h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk2fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk2fb"><hr></label><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2fc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2fd"><span class="nb">apply</span> (exist _ []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n ‚Üî In _0 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2fe"><span class="nb">subst</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">0</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = <span class="mi">0</span> ‚Üî In _0 []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk2ff"><span class="nb">intros</span> tree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">0</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree = <span class="mi">0</span> ‚Üî In tree []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk300"><span class="nb">pose proof</span> oneLeqLeafCount tree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">0</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree = <span class="mi">0</span> ‚Üî In tree []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk301"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">0</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree = <span class="mi">0</span> ‚Üî <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk302">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk303"><span class="nb">destruct</span> (decide (n = <span class="mi">1</span>)) <span class="kr">as</span> [h1 | h1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk304" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk304"><hr></label><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk305">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk306"><span class="nb">subst</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = <span class="mi">1</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk307"><span class="nb">apply</span> (exist _ [Unit]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = <span class="mi">1</span> ‚Üî In _0 [Unit]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk308"><span class="nb">intros</span> tree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree = <span class="mi">1</span> ‚Üî In tree [Unit]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk309"><span class="nb">destruct</span> tree <span class="kr">as</span> [| tree1 tree2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = <span class="mi">1</span> ‚Üî In Unit [Unit]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk30a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk30a"><hr></label><div class="goal-conclusion">leafCount (Unite tree1 tree2) = <span class="mi">1</span>
‚Üî In (Unite tree1 tree2) [Unit]</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = <span class="mi">1</span> ‚Üî In Unit [Unit]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span> ‚Üî Unit = Unit ‚à® <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite tree1 tree2) = <span class="mi">1</span>
‚Üî In (Unite tree1 tree2) [Unit]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span>
‚Üî Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk30f"><span class="nb">pose proof</span> oneLeqLeafCount tree1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span>
‚Üî Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk310" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk310"><span class="nb">pose proof</span> oneLeqLeafCount tree2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span>
‚Üî Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk311"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span>
‚Üí Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk312" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk312"><hr></label><div class="goal-conclusion">Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span>
‚Üí leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk313">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span>
‚Üí Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk314">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span>
‚Üí leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk315"><span class="nb">intro</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Unit = Unite tree1 tree2 ‚à® <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk316" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk316"><span class="nb">destruct</span> h1 <span class="kr">as</span> [h1 | h1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Unit = Unite tree1 tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk317" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk317"><hr></label><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk318">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Unit = Unite tree1 tree2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk319"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : Unit &lt;&gt; Unite tree1 tree2) h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Unit = Unite tree1 tree2</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31a"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Unit = Unite tree1 tree2</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree1 + leafCount tree2 = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31c"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; <span class="mi">1</span>
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>tree1, tree2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree1</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount tree2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk31e"><span class="nb">assert</span> (h2 : <span class="kr">forall</span> (<span class="nv">leftSize</span> : nat) (<span class="nv">hLeft</span> : leftSize &lt; n) (<span class="nv">hLeft2</span> : <span class="mi">0</span> &lt; leftSize), {x : list Tree | <span class="kr">forall</span> <span class="nv">tree</span> : Tree, (<span class="kr">match</span> tree <span class="kr">with</span> | Unit =&gt; <span class="kt">False</span> | Unite a b =&gt; leafCount a &lt;= leftSize /\ leafCount b = n - leafCount a <span class="kr">end</span>) &lt;-&gt; In tree x}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk31f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk31f"><hr></label><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk320" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk320">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk321" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk321"><span class="nb">intros</span> <span class="nb">left</span> hLeft hLeft2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk322"><span class="nb">induction</span> <span class="nb">left</span> <span class="kr">as</span> [| <span class="nb">left</span> IH2]; [<span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk323"><span class="nb">pose proof</span> IH (S <span class="nb">left</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kr">as</span> [a ha].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk324"><span class="nb">pose proof</span> IH (n - S <span class="nb">left</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kr">as</span> [b hb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk325"><span class="nb">destruct</span> (decide (<span class="nb">left</span> = <span class="mi">0</span>)) <span class="kr">as</span> [h2 | h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk326" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk326"><hr></label><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk327">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk328"><span class="nb">apply</span> (exist _ (map (<span class="kr">fun</span> (<span class="nv">x</span> : Tree * Tree) =&gt; <span class="kr">let</span> (<span class="nv">a</span>, b) := x <span class="kr">in</span> Unite a b) (generateProduct a b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ S <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span>
  ‚Üî In _0
      (map
         (<span class="kr">Œª</span> <span class="nv">_1</span> : Tree * Tree,
            <span class="kr">let</span> (<span class="nv">_2</span>, _3) := _1 <span class="kr">in</span> Unite _2 _3)
         (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk329"><span class="nb">intros</span> [| a1 b1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üî In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk32a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk32a"><hr></label><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üî In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk32b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üî In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk32c"><span class="nb">split</span>; <span class="nb">intro</span> hTree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk32d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk32d"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk32e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk32f"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hTree.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk330">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk331"><span class="nb">remember</span> (generateProduct a b) <span class="kr">as</span> l <span class="nb">eqn</span>:hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l = generateProduct a b</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk332"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH3] <span class="kr">in</span> hTree |-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk333" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (head :: tail))</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk333"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk334">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk335"><span class="nb">simpl</span> <span class="kr">in</span> hTree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hTree.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk336">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (head :: tail))</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk337"><span class="nb">destruct</span> hTree <span class="kr">as</span> [hTree | hTree].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span> Unite _0 _1) = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk338" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     tail)</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk338"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk339">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span> Unite _0 _1) = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33a"><span class="nb">destruct</span> head <span class="kr">as</span> [aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((<span class="kp">ltac</span>:(<span class="bp">easy</span>) : Unite aa bb &lt;&gt; Unit) hTree).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hTree</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     tail)</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üî In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33d"><span class="nb">pose proof</span> oneLeqLeafCount a1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üî In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33e"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : leafCount a1 &lt;= S <span class="nb">left</span> &lt;-&gt; leafCount a1 = S <span class="nb">left</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üî In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk33f"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk340" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk340"><hr></label><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚Üí leafCount a1 = S <span class="nb">left</span>
  ‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk341">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk342"><span class="nb">intros</span> [hTree1 hTree2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk343"><span class="nb">pose proof</span> in_map (<span class="kr">fun</span> (<span class="nv">x</span> : Tree * Tree) =&gt; <span class="kr">let</span> (<span class="nv">a</span>, b) := x <span class="kr">in</span> Unite a b) (generateProduct a b) (a1, b1) <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In
    ((<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (a1, b1))
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk344"><span class="nb">simpl</span> <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk345"><span class="nb">apply</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (a1, b1) (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk346"><span class="nb">apply</span> inProductList.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In a1 a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk347" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk347"><hr></label><div class="goal-conclusion">In b1 b</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk348">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In a1 a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk349"><span class="nb">rewrite</span> &lt;- ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In b1 b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34b"><span class="nb">rewrite</span> &lt;- hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hTree1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hTree2</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - leafCount a1</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)
‚Üí In (Unite a1 b1)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount b1 = n - S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚Üí leafCount a1 = S <span class="nb">left</span>
  ‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚Üí leafCount a1 = S <span class="nb">left</span>
  ‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34e"><span class="nb">rewrite</span> in_map_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">_0</span> : Tree * Tree,
   (<span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) = Unite a1 b1
   ‚àß In _0 (generateProduct a b))
‚Üí leafCount a1 = S <span class="nb">left</span>
  ‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk34f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk34f"><span class="nb">intros</span> [[aa bb] [h4 h3]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (aa, bb) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk350" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk350"><span class="nb">pose proof</span> inProductList2 a b aa bb h3 <span class="kr">as</span> [hIn1 hIn2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (aa, bb) (generateProduct a b)</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>In aa a</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In bb b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk351"><span class="nb">rewrite</span> &lt;- ha <span class="kr">in</span> hIn1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (aa, bb) (generateProduct a b)</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In bb b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk352"><span class="nb">injection</span> h4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (aa, bb) (generateProduct a b)</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In bb b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bb = b1
‚Üí aa = a1
  ‚Üí leafCount a1 = S <span class="nb">left</span>
    ‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk353"><span class="nb">intros</span> hbb haa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (aa, bb) (generateProduct a b)</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In bb b</span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>bb = b1</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>aa = a1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk354" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk354"><span class="nb">subst</span> aa bb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk355"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk356" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk356"><hr></label><div class="goal-conclusion">leafCount b1 = n - leafCount a1</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk357">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 = S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hIn1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk358" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk358">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk359"><span class="nb">pose proof</span> hb b1 <span class="kr">as</span> hb1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hb1</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - S <span class="nb">left</span> ‚Üî In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk35a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk35a"><span class="nb">rewrite</span> hIn1, hb1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> = <span class="mi">0</span></span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a1</span></span></span><br><span><var>hIn1</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hb1</var><span class="hyp-type"><b>: </b><span>leafCount b1 = n - S <span class="nb">left</span> ‚Üî In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In b1 b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk35b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk35b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk35c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk35c"><span class="nb">pose proof</span> IH2 <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kr">as</span> [previous hPrevious].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
    <span class="kr">match</span> _1 <span class="kr">with</span>
    | Unit =&gt; <span class="kt">False</span>
    | Unite _2 _3 =&gt;
        leafCount _2 ‚â§ S <span class="nb">left</span>
        ‚àß leafCount _3 = n - leafCount _2
    <span class="kr">end</span> ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk35d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk35d"><span class="nb">apply</span> (exist _ (map (<span class="kr">fun</span> (<span class="nv">x</span> : Tree * Tree) =&gt; <span class="kr">let</span> (<span class="nv">a</span>, b) := x <span class="kr">in</span> Unite a b) (generateProduct a b) ++ previous)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ S <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span>
  ‚Üî In _0
      (map
         (<span class="kr">Œª</span> <span class="nv">_1</span> : Tree * Tree,
            <span class="kr">let</span> (<span class="nv">_2</span>, _3) := _1 <span class="kr">in</span> Unite _2 _3)
         (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk35e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk35e"><span class="nb">intros</span> [| aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üî In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk35f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk35f"><hr></label><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üî In (Unite aa bb)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk360">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üî In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk361" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk361"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üí In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk362" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk362"><hr></label><div class="goal-conclusion">In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous) ‚Üí <span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk363" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk363">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span>
‚Üí In Unit
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk364" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk364">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk365" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk365"><span class="nb">intro</span> h3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk366"><span class="nb">pose proof</span> in_app_or _ _ _ h3 <span class="kr">as</span> [H | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk367" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit previous</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk367"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk368">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk369" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk369"><span class="nb">remember</span> (generateProduct a b) <span class="kr">as</span> l <span class="nb">eqn</span>:hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>l = generateProduct a b</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) l ++
   previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36a"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH3] <span class="kr">in</span> H |-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk36b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (head :: tail))</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk36b"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36d"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (head :: tail))</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk36f"><span class="nb">destruct</span> H <span class="kr">as</span> [H | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span> Unite _0 _1) = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk370" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk370"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk371">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">_0</span>, _1) := head <span class="kr">in</span> Unite _0 _1) = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk372"><span class="nb">destruct</span> head <span class="kr">as</span> [aa bb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Unite aa bb = Unit</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((<span class="kp">ltac</span>:(<span class="bp">easy</span>) : Unite aa bb &lt;&gt; Unit) H).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk373" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk373">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>head</var><span class="hyp-type"><b>: </b><span>(Tree * Tree)%type</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (Tree * Tree)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)</span></span></span><br><span><var>IH3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) tail)
‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IH3 H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk374">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk375" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk375"><span class="nb">pose proof</span> hPrevious Unit <span class="kr">as</span> [_ step].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>In Unit
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In Unit previous</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In Unit previous ‚Üí <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (step H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk376" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk376">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üî In (Unite aa bb)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk377" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk377"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üí In (Unite aa bb)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk378" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk378"><hr></label><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)
‚Üí leafCount aa ‚â§ S <span class="nb">left</span>
  ‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk379">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üí In (Unite aa bb)
    (map
       (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
          <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
       (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37a"><span class="nb">intros</span> [haa hbb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37b"><span class="nb">apply</span> in_or_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚à® In (Unite aa bb) previous</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37c"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : leafCount aa &lt;= <span class="nb">left</span> \/ leafCount aa = S <span class="nb">left</span>) <span class="kr">as</span> [hIf | hIf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚à® In (Unite aa bb) previous</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk37d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk37d"><hr></label><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚à® In (Unite aa bb) previous</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚à® In (Unite aa bb) previous</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk37f"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb) previous</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk380" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk380"><span class="nb">rewrite</span> &lt;- (hPrevious (Unite aa bb)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ <span class="nb">left</span> ‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk381"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ <span class="nb">left</span> ‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk382" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk382">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))
‚à® In (Unite aa bb) previous</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk383" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk383"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk384"><span class="nb">rewrite</span> in_map_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_0</span> : Tree * Tree,
  (<span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) = Unite aa bb
  ‚àß In _0 (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk385" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk385"><span class="kr">exists</span> (<span class="nv">aa</span>, bb).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite aa bb = Unite aa bb
‚àß In (aa, bb) (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk386" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk386"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite aa bb = Unite aa bb</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk387" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk387"><hr></label><div class="goal-conclusion">In (aa, bb) (generateProduct a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk388" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk388">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite aa bb = Unite aa bb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk389">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (aa, bb) (generateProduct a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38a"><span class="nb">apply</span> inProductList.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In aa a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk38b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk38b"><hr></label><div class="goal-conclusion">In bb b</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In aa a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38d"><span class="nb">rewrite</span> &lt;- ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa = S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In bb b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk38f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk38f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In bb b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk390" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk390"><span class="nb">rewrite</span> &lt;- hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ S <span class="nb">left</span></span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>leafCount bb = n - leafCount aa</span></span></span><br><span><var>hIf</var><span class="hyp-type"><b>: </b><span>leafCount aa = S <span class="nb">left</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount bb = n - S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk391" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk391">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)
‚Üí leafCount aa ‚â§ S <span class="nb">left</span>
  ‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk392" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk392"><span class="nb">intro</span> hmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk393" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk393"><span class="nb">pose proof</span> in_app_or _ _ _ hmap <span class="kr">as</span> [H | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk394" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb) previous</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk394"><hr></label><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk395" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk395">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk396" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk396"><span class="nb">rewrite</span> in_map_iff <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">_0</span> : Tree * Tree,
  (<span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2) =
  Unite aa bb ‚àß In _0 (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk397" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk397"><span class="nb">destruct</span> H <span class="kr">as</span> [[a1 b1] [hinj hin]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite aa bb</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk398" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk398"><span class="nb">injection</span> hinj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite aa bb</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b1 = bb
‚Üí a1 = aa
  ‚Üí leafCount aa ‚â§ S <span class="nb">left</span>
    ‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk399" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk399"><span class="nb">intros</span> hbb haa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>a1, b1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite aa bb</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hbb</var><span class="hyp-type"><b>: </b><span>b1 = bb</span></span></span><br><span><var>haa</var><span class="hyp-type"><b>: </b><span>a1 = aa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39a"><span class="nb">subst</span> bb aa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39b"><span class="nb">pose proof</span> inProductList2 _ _ _ _ hin <span class="kr">as</span> [hina hinb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>In a1 a</span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39c"><span class="nb">rewrite</span> &lt;- ha <span class="kr">in</span> hina.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span>
‚àß leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39d"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk39e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk39e"><hr></label><div class="goal-conclusion">leafCount b1 = n - leafCount a1</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk39f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk39f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a1 ‚â§ S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount b1 = n - leafCount a1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a1"><span class="nb">rewrite</span> hina.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount b1 = n - S <span class="nb">left</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a2"><span class="nb">rewrite</span> hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>b1, a1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite a1 b1)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>hinj</var><span class="hyp-type"><b>: </b><span>Unite a1 b1 = Unite a1 b1</span></span></span><br><span><var>hin</var><span class="hyp-type"><b>: </b><span>In (a1, b1) (generateProduct a b)</span></span></span><br><span><var>hina</var><span class="hyp-type"><b>: </b><span>leafCount a1 = S <span class="nb">left</span></span></span></span><br><span><var>hinb</var><span class="hyp-type"><b>: </b><span>In b1 b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In b1 b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hinb.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb) previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a4"><span class="nb">pose proof</span> hPrevious (Unite aa bb) <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb) previous</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> Unite aa bb <span class="kr">with</span>
| Unit =&gt; <span class="kt">False</span>
| Unite _0 _1 =&gt;
    leafCount _0 ‚â§ <span class="nb">left</span>
    ‚àß leafCount _1 = n - leafCount _0
<span class="kr">end</span> ‚Üî In (Unite aa bb) previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a5"><span class="nb">simpl</span> <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb) previous</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üî In (Unite aa bb) previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a6"><span class="nb">rewrite</span> &lt;- step <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hLeft</var><span class="hyp-type"><b>: </b><span>S <span class="nb">left</span> &lt; n</span></span></span><br><span><var>hLeft2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; S <span class="nb">left</span></span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> &lt; n
‚Üí <span class="mi">0</span> &lt; <span class="nb">left</span>
  ‚Üí {_0 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree,
        <span class="kr">match</span> _1 <span class="kr">with</span>
        | Unit =&gt; <span class="kt">False</span>
        | Unite _2 _3 =&gt;
            leafCount _2 ‚â§ <span class="nb">left</span>
            ‚àß leafCount _3 = n - leafCount _2
        <span class="kr">end</span> ‚Üî In _1 _0}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S <span class="nb">left</span> ‚Üî In _0 a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n - S <span class="nb">left</span> ‚Üî In _0 b</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="nb">left</span> ‚â† <span class="mi">0</span></span></span></span><br><span><var>previous</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hPrevious</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ <span class="nb">left</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 previous</span></span></span><br><span><var>aa, bb</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hmap</var><span class="hyp-type"><b>: </b><span>In (Unite aa bb)
  (map
     (<span class="kr">Œª</span> <span class="nv">_0</span> : Tree * Tree,
        <span class="kr">let</span> (<span class="nv">_1</span>, _2) := _0 <span class="kr">in</span> Unite _1 _2)
     (generateProduct a b) ++ previous)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount aa ‚â§ <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa
‚Üî In (Unite aa bb) previous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount aa ‚â§ S <span class="nb">left</span>
‚àß leafCount bb = n - leafCount aa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a8"><span class="nb">pose proof</span> h2 (n - <span class="mi">1</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kr">as</span> [l hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : list Tree
| <span class="kr">‚àÄ</span> <span class="nv">_1</span> : Tree, leafCount _1 = n ‚Üî In _1 _0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3a9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3a9"><span class="nb">apply</span> (exist _ l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = n ‚Üî In _0 l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3aa" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3aa"><span class="nb">intro</span> tree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>tree</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount tree = n ‚Üî In tree l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ab" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ab"><span class="nb">destruct</span> tree <span class="kr">as</span> [| a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = n ‚Üî In Unit l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3ac"><hr></label><div class="goal-conclusion">leafCount (Unite a b) = n ‚Üî In (Unite a b) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ad" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ad">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = n ‚Üî In Unit l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ae" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ae"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = n ‚Üí In Unit l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3af"><hr></label><div class="goal-conclusion">In Unit l ‚Üí leafCount Unit = n</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount Unit = n ‚Üí In Unit l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = n ‚Üí In Unit l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b2"><span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit l ‚Üí leafCount Unit = n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b4"><span class="nb">pose proof</span> hl Unit <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> Unit <span class="kr">with</span>
| Unit =&gt; <span class="kt">False</span>
| Unite _0 _1 =&gt;
    leafCount _0 ‚â§ n - <span class="mi">1</span>
    ‚àß leafCount _1 = n - leafCount _0
<span class="kr">end</span> ‚Üî In Unit l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit l ‚Üí leafCount Unit = n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b5"><span class="nb">simpl</span> <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span> ‚Üî In Unit l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In Unit l ‚Üí leafCount Unit = n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b6"><span class="nb">rewrite</span> &lt;- step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span> ‚Üî In Unit l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> ‚Üí leafCount Unit = n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a b) = n ‚Üî In (Unite a b) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b8"><span class="nb">rewrite</span> &lt;- (hl (Unite a b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (Unite a b) = n
‚Üî leafCount a ‚â§ n - <span class="mi">1</span> ‚àß leafCount b = n - leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3b9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3b9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b = n
‚Üî leafCount a ‚â§ n - <span class="mi">1</span> ‚àß leafCount b = n - leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ba" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ba"><span class="nb">pose proof</span> oneLeqLeafCount b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí {_1 : list Tree
    | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree, leafCount _2 = _0 ‚Üî In _2 _1}</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">0</span></span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>n ‚â† <span class="mi">1</span></span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : nat,
  _0 &lt; n
  ‚Üí <span class="mi">0</span> &lt; _0
    ‚Üí {_1 : list Tree
      | <span class="kr">‚àÄ</span> <span class="nv">_2</span> : Tree,
          <span class="kr">match</span> _2 <span class="kr">with</span>
          | Unit =&gt; <span class="kt">False</span>
          | Unite _3 _4 =&gt;
              leafCount _3 ‚â§ _0
              ‚àß leafCount _4 = n - leafCount _3
          <span class="kr">end</span> ‚Üî In _2 _1}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="kr">match</span> _0 <span class="kr">with</span>
  | Unit =&gt; <span class="kt">False</span>
  | Unite _1 _2 =&gt;
      leafCount _1 ‚â§ n - <span class="mi">1</span>
      ‚àß leafCount _2 = n - leafCount _1
  <span class="kr">end</span> ‚Üî In _0 l</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount a + leafCount b = n
‚Üî leafCount a ‚â§ n - <span class="mi">1</span> ‚àß leafCount b = n - leafCount a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">optimalTree</span> (<span class="nv">x</span> : Tree) := <span class="kr">forall</span> <span class="nv">y</span>, leafCount x = leafCount y -&gt; score y &lt;= score x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bestTree</span> (<span class="nv">l</span> : list Tree) (<span class="nv">currentBest</span> : Tree) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; currentBest
  | head :: tail =&gt;
    <span class="kr">if</span> decide (score currentBest &lt; score head) <span class="kr">then</span>
      bestTree tail head
    <span class="kr">else</span> bestTree tail currentBest
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3bb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3bb"><span class="kn">Lemma</span> <span class="nf">currentBestLeqBestTree</span> (<span class="nv">l</span> : list Tree) (<span class="nv">currentBest</span> : Tree) : score currentBest &lt;= score (bestTree l currentBest).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree l currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3bc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3bc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree l currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3bd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3bd"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH] <span class="kr">in</span> currentBest |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree [] currentBest)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3be"><hr></label><div class="goal-conclusion">score currentBest
‚â§ score (bestTree (head :: tail) currentBest)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3bf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree [] currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c0"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score currentBest</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest
‚â§ score (bestTree (head :: tail) currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest
‚â§ score
    (<span class="kr">if</span> decide (score currentBest &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c3">case_decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score currentBest &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree tail head)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score currentBest &lt; score head</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3c4"><hr></label><div class="goal-conclusion">score currentBest ‚â§ score (bestTree tail currentBest)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score currentBest &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree tail head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c6"><span class="nb">pose proof</span> IH head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score currentBest &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree tail head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, score _0 ‚â§ score (bestTree tail _0)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score currentBest &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score (bestTree tail currentBest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c8"><span class="kn">Lemma</span> <span class="nf">differentCurrentBest</span> (<span class="nv">l</span> : list Tree) (<span class="nv">currentBest</span> <span class="nv">currentBest1</span> : Tree) (<span class="nv">hLeq</span> : score currentBest &lt;= score currentBest1) : score (bestTree l currentBest) &lt;= score (bestTree l currentBest1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (bestTree l currentBest)
‚â§ score (bestTree l currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3c9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3c9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (bestTree l currentBest)
‚â§ score (bestTree l currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ca" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ca"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH] <span class="kr">in</span> currentBest, hLeq |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (bestTree [] currentBest)
‚â§ score (bestTree [] currentBest1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â§ score currentBest1
  ‚Üí score (bestTree tail _0)
    ‚â§ score (bestTree tail currentBest1)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3cb"><hr></label><div class="goal-conclusion">score (bestTree (head :: tail) currentBest)
‚â§ score (bestTree (head :: tail) currentBest1)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3cc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3cc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (bestTree [] currentBest)
‚â§ score (bestTree [] currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3cd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3cd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score currentBest ‚â§ score currentBest1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ce" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ce">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â§ score currentBest1
  ‚Üí score (bestTree tail _0)
    ‚â§ score (bestTree tail currentBest1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (bestTree (head :: tail) currentBest)
‚â§ score (bestTree (head :: tail) currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3cf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3cf"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â§ score currentBest1
  ‚Üí score (bestTree tail _0)
    ‚â§ score (bestTree tail currentBest1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
  (<span class="kr">if</span> decide (score currentBest &lt; score head)
   <span class="kr">then</span> bestTree tail head
   <span class="kr">else</span> bestTree tail currentBest)
‚â§ score
    (<span class="kr">if</span> decide (score currentBest1 &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d0"><span class="nb">pose proof</span> IH currentBest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â§ score currentBest1
  ‚Üí score (bestTree tail _0)
    ‚â§ score (bestTree tail currentBest1)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1
‚Üí score (bestTree tail currentBest)
  ‚â§ score (bestTree tail currentBest1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
  (<span class="kr">if</span> decide (score currentBest &lt; score head)
   <span class="kr">then</span> bestTree tail head
   <span class="kr">else</span> bestTree tail currentBest)
‚â§ score
    (<span class="kr">if</span> decide (score currentBest1 &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d1"><span class="nb">pose proof</span> IH head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>currentBest, currentBest1</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hLeq</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â§ score currentBest1
  ‚Üí score (bestTree tail _0)
    ‚â§ score (bestTree tail currentBest1)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score currentBest ‚â§ score currentBest1
‚Üí score (bestTree tail currentBest)
  ‚â§ score (bestTree tail currentBest1)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score currentBest1
‚Üí score (bestTree tail head)
  ‚â§ score (bestTree tail currentBest1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score
  (<span class="kr">if</span> decide (score currentBest &lt; score head)
   <span class="kr">then</span> bestTree tail head
   <span class="kr">else</span> bestTree tail currentBest)
‚â§ score
    (<span class="kr">if</span> decide (score currentBest1 &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail currentBest1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> case_decide; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d2"><span class="kn">Lemma</span> <span class="nf">bestTreeIsBest</span> (<span class="nv">l</span> : list Tree) (<span class="nv">x</span> : Tree) (<span class="nv">hIn</span> : In x l) (<span class="nv">arbitrary</span> : Tree) (<span class="nv">hIn2</span> : In arbitrary l) : score arbitrary &lt;= score (bestTree l x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d4"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x []</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [] x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x (head :: tail)</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3d5"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x []</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [] x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d7"><span class="nb">simpl</span> <span class="kr">in</span> hIn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [] x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d8"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> hIn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3d9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x (head :: tail)</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3da" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3da"><span class="nb">destruct</span> hIn <span class="kr">as</span> [hIn | hIn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>head = x</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3db"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3dc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3dc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>head = x</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3dd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3dd"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In head tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3de" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3de"><span class="nb">destruct</span> hIn2 <span class="kr">as</span> [hIn2 | hIn2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>head = arbitrary</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In head tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3df" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In head tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail head)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3df"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>head = arbitrary</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In head tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e1"><span class="nb">subst</span> head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary
    ‚â§ score (bestTree tail arbitrary)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score (bestTree (arbitrary :: tail) arbitrary)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary
    ‚â§ score (bestTree tail arbitrary)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score arbitrary &lt; score arbitrary)
     <span class="kr">then</span> bestTree tail arbitrary
     <span class="kr">else</span> bestTree tail arbitrary)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_decide; <span class="nb">apply</span> currentBestLeqBestTree.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In head tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e4"><span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e5"><span class="nb">induction</span> tail <span class="kr">as</span> [| hh ta IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [head] head)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary
  ‚â§ score (bestTree (head :: ta) head)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3e6"><hr></label><div class="goal-conclusion">score arbitrary
‚â§ score (bestTree (head :: hh :: ta) head)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [head] head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e8"><span class="nb">simpl</span> <span class="kr">in</span> hIn2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree [head] head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3e9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3e9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary
  ‚â§ score (bestTree (head :: ta) head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score (bestTree (head :: hh :: ta) head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ea" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ea"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary
  ‚â§ score (bestTree (head :: ta) head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score head &lt; score head)
     <span class="kr">then</span>
      <span class="kr">if</span> decide (score head &lt; score hh)
      <span class="kr">then</span> bestTree ta hh
      <span class="kr">else</span> bestTree ta head
     <span class="kr">else</span>
      <span class="kr">if</span> decide (score head &lt; score hh)
      <span class="kr">then</span> bestTree ta hh
      <span class="kr">else</span> bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3eb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3eb">case_decide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary
  ‚â§ score (bestTree (head :: ta) head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score head &lt; score hh)
     <span class="kr">then</span> bestTree ta hh
     <span class="kr">else</span> bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ec" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ec"><span class="nb">simpl</span> <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary
  ‚â§ score
      (<span class="kr">if</span> decide (score head &lt; score head)
       <span class="kr">then</span> bestTree ta head
       <span class="kr">else</span> bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score head &lt; score hh)
     <span class="kr">then</span> bestTree ta hh
     <span class="kr">else</span> bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ed" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ed">case_decide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score head &lt; score hh)
     <span class="kr">then</span> bestTree ta hh
     <span class="kr">else</span> bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ee" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ee">case_decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3ef"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f1"><span class="nb">destruct</span> hIn2 <span class="kr">as</span> [h | h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hh = arbitrary</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3f2"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hh = arbitrary</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f4"><span class="nb">subst</span> hh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score arbitrary</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta arbitrary)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> currentBestLeqBestTree.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f6"><span class="nb">pose proof</span> IH h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f7"><span class="nb">pose proof</span> differentCurrentBest ta head hh <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head &lt; score hh</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>score (bestTree ta head) ‚â§ score (bestTree ta hh)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta hh)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (hh :: ta)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3f9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3f9"><span class="nb">destruct</span> hIn2 <span class="kr">as</span> [h | h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hh = arbitrary</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk3fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk3fa"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3fb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3fb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>hh = arbitrary</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3fc" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3fc"><span class="nb">subst</span> hh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score arbitrary</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3fd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3fd"><span class="nb">pose proof</span> currentBestLeqBestTree ta arbitrary.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score arbitrary</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree ta arbitrary)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3fe" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3fe"><span class="nb">pose proof</span> differentCurrentBest ta arbitrary head <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score arbitrary</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree ta arbitrary)</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>score (bestTree ta arbitrary)
‚â§ score (bestTree ta head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk3ff" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk3ff">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head, hh</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>ta</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>In arbitrary ta</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In arbitrary ta
‚Üí score arbitrary ‚â§ score (bestTree ta head)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>¬¨ score head &lt; score hh</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree ta head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IH h).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk400" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk400">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary (head :: tail)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk401" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk401"><span class="nb">destruct</span> hIn2 <span class="kr">as</span> [hIn2 | hIn2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>head = arbitrary</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk402" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk402"><hr></label><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk403" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk403">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>head = arbitrary</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk404" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk404"><span class="nb">subst</span> arbitrary.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk405" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk405"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head
‚â§ score
    (<span class="kr">if</span> decide (score x &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk406" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk406">case_decide; <span class="nb">pose proof</span> currentBestLeqBestTree tail head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head ‚â§ score (bestTree tail head)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk407" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk407"><hr></label><div class="goal-conclusion">score head ‚â§ score (bestTree tail x)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk408" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk408">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head ‚â§ score (bestTree tail head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk409" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk409">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head ‚â§ score (bestTree tail x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40a"><span class="nb">pose proof</span> differentCurrentBest tail head x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In head tail
  ‚Üí score head ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score (bestTree tail head)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score head ‚â§ score x
‚Üí score (bestTree tail head)
  ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score head ‚â§ score (bestTree tail x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40c"><span class="nb">pose proof</span> IH hIn hIn2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree (head :: tail) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary
‚â§ score
    (<span class="kr">if</span> decide (score x &lt; score head)
     <span class="kr">then</span> bestTree tail head
     <span class="kr">else</span> bestTree tail x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40e">case_decide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree tail head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk40f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk40f"><span class="nb">pose proof</span> differentCurrentBest tail x head <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn</var><span class="hyp-type"><b>: </b><span>In x tail</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hIn2</var><span class="hyp-type"><b>: </b><span>In arbitrary tail</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>In x tail
‚Üí In arbitrary tail
  ‚Üí score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score arbitrary ‚â§ score (bestTree tail x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>score (bestTree tail x)
‚â§ score (bestTree tail head)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree tail head)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk410" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk410"><span class="kn">Lemma</span> <span class="nf">bestTreeInList</span> (<span class="nv">l</span> : list Tree) (<span class="nv">x</span> : Tree) : In (bestTree l x) l \/ bestTree l x = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l ‚à® bestTree l x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk411" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk411"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l ‚à® bestTree l x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk412" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk412"><span class="nb">induction</span> l <span class="kr">as</span> [| head tail IH] <span class="kr">in</span> x |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree [] x) [] ‚à® bestTree [] x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk413" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk413"><hr></label><div class="goal-conclusion">In (bestTree (head :: tail) x) (head :: tail)
‚à® bestTree (head :: tail) x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk414" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk414">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree [] x) [] ‚à® bestTree [] x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk415" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk415"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> ‚à® x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk416" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk416"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk417" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk417">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree (head :: tail) x) (head :: tail)
‚à® bestTree (head :: tail) x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk418" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk418"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head =
 (<span class="kr">if</span> decide (score x &lt; score head)
  <span class="kr">then</span> bestTree tail head
  <span class="kr">else</span> bestTree tail x)
 ‚à® In
     (<span class="kr">if</span> decide (score x &lt; score head)
      <span class="kr">then</span> bestTree tail head
      <span class="kr">else</span> bestTree tail x) tail)
‚à® (<span class="kr">if</span> decide (score x &lt; score head)
   <span class="kr">then</span> bestTree tail head
   <span class="kr">else</span> bestTree tail x) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk419" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk419">case_decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk41a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk41a"><hr></label><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk41b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk41b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk41c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk41c"><span class="nb">pose proof</span> IH head <span class="kr">as</span> [a | b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail head) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk41d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk41d"><hr></label><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk41e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk41e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail head) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk41f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk41f"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail head) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head = bestTree tail head
‚à® In (bestTree tail head) tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk420" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk420"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail head) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree tail head) tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> a.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk421" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk421">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk422" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk422">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail head
 ‚à® In (bestTree tail head) tail)
‚à® bestTree tail head = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk423" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk423"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head = bestTree tail head
‚à® In (bestTree tail head) tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk424" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk424"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head = bestTree tail head</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk425" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk425"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail head = head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bestTree tail head = head</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> b.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk426" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk426">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk427" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk427"><span class="nb">pose proof</span> IH x <span class="kr">as</span> [a | b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail x) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk428" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail x = x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk428"><hr></label><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk429" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk429">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail x) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42a"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail x) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head = bestTree tail x ‚à® In (bestTree tail x) tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42b"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree tail x) tail</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree tail x) tail</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> a.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(head = bestTree tail x ‚à® In (bestTree tail x) tail)
‚à® bestTree tail x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42e"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In (bestTree tail _0) tail
  ‚à® bestTree tail _0 = _0</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>¬¨ score x &lt; score head</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bestTree tail x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bestTree tail x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> b.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk42f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk42f"><span class="kn">Lemma</span> <span class="nf">bestTreeInList2</span> (<span class="nv">l</span> : list Tree) (<span class="nv">x</span> : Tree) (<span class="nv">hX</span> : In x l) : In (bestTree l x) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk430" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk430"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk431" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk431"><span class="nb">pose proof</span> bestTreeInList l x <span class="kr">as</span> [a | a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree l x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk432" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>bestTree l x = x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk432"><hr></label><div class="goal-conclusion">In (bestTree l x) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk433" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk433">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>In (bestTree l x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk434" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk434">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>bestTree l x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (bestTree l x) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk435" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk435"><span class="nb">rewrite</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>hX</var><span class="hyp-type"><b>: </b><span>In x l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>bestTree l x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In x l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk436" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk436"><span class="kn">Lemma</span> <span class="nf">getOptimalTree</span> (<span class="nv">n</span> : nat) : { x : Tree | optimalTree x /\ leafCount x = S n }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk437" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk437"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk438" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk438"><span class="nb">pose proof</span> enumerateTrees (S n) <span class="kr">as</span> [l spec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk439" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk439"><span class="nb">pose proof</span> spec (constructTree n) <span class="kr">as</span> [h _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43a"><span class="nb">pose proof</span> h (constructTreeSize n) <span class="kr">as</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43b"><span class="nb">pose proof</span> bestTreeIsBest l _ h1 <span class="kr">as</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_0 : Tree | optimalTree _0 ‚àß leafCount _0 = S n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43c"><span class="nb">apply</span> (exist _ (bestTree l (constructTree n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (bestTree l (constructTree n))
‚àß leafCount (bestTree l (constructTree n)) = S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43d"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (bestTree l (constructTree n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk43e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk43e"><hr></label><div class="goal-conclusion">leafCount (bestTree l (constructTree n)) = S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk43f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk43f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk440" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk440"><span class="nb">intros</span> arbitrary h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk441" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk441"><span class="nb">pose proof</span> H arbitrary <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>In arbitrary l
‚Üí score arbitrary
  ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk442" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk442"><span class="nb">rewrite</span> &lt;- spec <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount arbitrary = S n
‚Üí score arbitrary
  ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk443" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk443"><span class="nb">rewrite</span> &lt;- h2 <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) = S n
‚Üí score arbitrary
  ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk444" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk444"><span class="nb">pose proof</span> (bestTreeInList2 l (constructTree n) h1) <span class="kr">as</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) = S n
‚Üí score arbitrary
  ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>In (bestTree l (constructTree n)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk445" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk445"><span class="nb">rewrite</span> &lt;- spec <span class="kr">in</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>arbitrary</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) =
leafCount arbitrary</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) = S n
‚Üí score arbitrary
  ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score arbitrary ‚â§ score (bestTree l (constructTree n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (step g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk446" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk446">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (bestTree l (constructTree n)) = S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk447" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk447"><span class="nb">pose proof</span> (bestTreeInList2 l (constructTree n) h1) <span class="kr">as</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>In (bestTree l (constructTree n)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (bestTree l (constructTree n)) = S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk448" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk448"><span class="nb">rewrite</span> &lt;- spec <span class="kr">in</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Tree</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree, leafCount _0 = S n ‚Üî In _0 l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree n) = S n
‚Üí In (constructTree n) l</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>In (constructTree n) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  In _0 l
  ‚Üí score _0
    ‚â§ score (bestTree l (constructTree n))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>leafCount (bestTree l (constructTree n)) = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leafCount (bestTree l (constructTree n)) = S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk449" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk449"><span class="kn">Lemma</span> <span class="nf">noThreeRules</span> (<span class="nv">x</span> : Tree) (<span class="nv">h1</span> : hasRule1 x = false) (<span class="nv">h2</span> : hasRule2 x = false) (<span class="nv">h3</span> : hasRule3 x = false) : x = constructTree (leafCount x - <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 x = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = constructTree (leafCount x - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 x = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = constructTree (leafCount x - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44b"><span class="nb">induction</span> x <span class="kr">as</span> [| a IHa b IHb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk44c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 a = false
‚Üí hasRule2 a = false
‚Üí hasRule3 a = false ‚Üí a = constructTree (leafCount a - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk44c"><hr></label><div class="goal-conclusion">Unite a b = constructTree (leafCount (Unite a b) - <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 Unit = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 Unit = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 a = false
‚Üí hasRule2 a = false
‚Üí hasRule3 a = false ‚Üí a = constructTree (leafCount a - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite a b = constructTree (leafCount (Unite a b) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk44f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk44f"><span class="nb">destruct</span> a <span class="kr">as</span> [| a1 a2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit b =
constructTree (leafCount (Unite Unit b) - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk450" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk450"><hr></label><div class="goal-conclusion">Unite (Unite a1 a2) b =
constructTree (leafCount (Unite (Unite a1 a2) b) - <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk451" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk451">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit b =
constructTree (leafCount (Unite Unit b) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk452" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk452"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit Unit) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit Unit) = false</span></span></span><br><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit Unit =
constructTree (leafCount (Unite Unit Unit) - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk453" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk453"><hr></label><div class="goal-conclusion">Unite Unit (Unite b1 b2) =
constructTree
  (leafCount (Unite Unit (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk454" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk454">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit Unit) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit Unit) = false</span></span></span><br><span><var>IHa, IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit Unit =
constructTree (leafCount (Unite Unit Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk455" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk455">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit (Unite b1 b2) =
constructTree
  (leafCount (Unite Unit (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk456" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk456"><span class="nb">simpl</span> <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>true = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite Unit (Unite b1 b2)) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite Unit (Unite b1 b2) =
constructTree
  (leafCount (Unite Unit (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk457" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk457">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) b) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 b = false
‚Üí hasRule2 b = false
‚Üí hasRule3 b = false ‚Üí b = constructTree (leafCount b - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) b =
constructTree (leafCount (Unite (Unite a1 a2) b) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk458" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk458"><span class="nb">destruct</span> b <span class="kr">as</span> [| b1 b2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk459" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk459"><hr></label><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45b"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule1 (Unite (Unite a1 a2) Unit) = hasRule1 (Unite a1 a2) || hasRule1 Unit) <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 Unit = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45c"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule1 Unit = false) <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || false = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45d"><span class="nb">rewrite</span> orb_false_r <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45e"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule2 (Unite (Unite a1 a2) Unit) = hasRule2 (Unite a1 a2)) <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) Unit) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk45f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk45f"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) Unit) = hasRule3 (Unite a1 a2)) <span class="kr">in</span> h3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk460" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk460"><span class="nb">pose proof</span> IHa h1 h2 h3 <span class="kr">as</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Unite a1 a2 =
constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree
  (leafCount (Unite (Unite a1 a2) Unit) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk461" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk461"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : <span class="kr">forall</span> <span class="nv">x</span>, leafCount (Unite x Unit) = leafCount x + <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Unite a1 a2 =
constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree (leafCount (Unite a1 a2) + <span class="mi">1</span> - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk462" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk462"><span class="nb">pose proof</span> oneLeqLeafCount (Unite a1 a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Unite a1 a2 =
constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree (leafCount (Unite a1 a2) + <span class="mi">1</span> - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk463" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk463"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : leafCount (Unite a1 a2) + <span class="mi">1</span> - <span class="mi">1</span> = S (leafCount (Unite a1 a2) - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 Unit = false
‚Üí hasRule2 Unit = false
‚Üí hasRule3 Unit = false ‚Üí Unit = constructTree (leafCount Unit - <span class="mi">1</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Unite a1 a2 =
constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount (Unite a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) Unit =
constructTree (S (leafCount (Unite a1 a2) - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">now</span> <span class="nb">rewrite</span> &lt;- h) : Unite (Unite a1 a2) Unit = Unite (constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)) Unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk464" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk464">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk465" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk465"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule1 (Unite (Unite a1 a2) (Unite b1 b2)) = hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2)) <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) || hasRule1 (Unite b1 b2) =
false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk466" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk466"><span class="nb">rewrite</span> orb_false_iff <span class="kr">in</span> h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk467" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk467"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule2 (Unite (Unite a1 a2) (Unite b1 b2)) = (leafCount b2 &lt;=? leafCount a1) || hasRule2 (Unite a1 a2) || hasRule2 (Unite b1 b2)) <span class="kr">in</span> h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1)
|| hasRule2 (Unite a1 a2)
|| hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) =
false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk468" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk468"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : hasRule3 (Unite (Unite a1 a2) (Unite b1 b2)) = (leafCount a1 &lt;? leafCount b2) || hasRule3 (Unite a1 a2) || hasRule3 (Unite b1 b2)) <span class="kr">in</span> h3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1)
|| hasRule2 (Unite a1 a2)
|| hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2)
|| hasRule3 (Unite a1 a2)
|| hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk469" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk469"><span class="nb">rewrite</span> orb_false_iff <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1)
|| hasRule2 (Unite a1 a2) = false
‚àß hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2)
|| hasRule3 (Unite a1 a2) = false
‚àß hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46a"><span class="nb">destruct</span> h2 <span class="kr">as</span> [h21 h22].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h21</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) || hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h22</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2)
|| hasRule3 (Unite a1 a2) = false
‚àß hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46b"><span class="nb">destruct</span> h3 <span class="kr">as</span> [h31 h32].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h21</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) || hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h22</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h31</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) || hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h32</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46c"><span class="nb">rewrite</span> orb_false_iff <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h21</var><span class="hyp-type"><b>: </b><span>(leafCount b2 &lt;=? leafCount a1) = false ‚àß hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h22</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h31</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false ‚àß hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h32</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46d"><span class="nb">rewrite</span> Nat.leb_gt <span class="kr">in</span> h21.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h21</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2 ‚àß hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h22</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h31</var><span class="hyp-type"><b>: </b><span>(leafCount a1 &lt;? leafCount b2) = false ‚àß hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h32</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46e"><span class="nb">rewrite</span> Nat.ltb_ge <span class="kr">in</span> h31.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2, b1, b2</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚àß hasRule1 (Unite b1 b2) = false</span></span></span><br><span><var>h21</var><span class="hyp-type"><b>: </b><span>leafCount a1 &lt; leafCount b2 ‚àß hasRule2 (Unite a1 a2) = false</span></span></span><br><span><var>h22</var><span class="hyp-type"><b>: </b><span>hasRule2 (Unite b1 b2) = false</span></span></span><br><span><var>h31</var><span class="hyp-type"><b>: </b><span>leafCount b2 ‚â§ leafCount a1 ‚àß hasRule3 (Unite a1 a2) = false</span></span></span><br><span><var>h32</var><span class="hyp-type"><b>: </b><span>hasRule3 (Unite b1 b2) = false</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite a1 a2) = false
‚Üí hasRule2 (Unite a1 a2) = false
‚Üí hasRule3 (Unite a1 a2) = false
‚Üí Unite a1 a2 = constructTree (leafCount (Unite a1 a2) - <span class="mi">1</span>)</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>hasRule1 (Unite b1 b2) = false
‚Üí hasRule2 (Unite b1 b2) = false
‚Üí hasRule3 (Unite b1 b2) = false
‚Üí Unite b1 b2 = constructTree (leafCount (Unite b1 b2) - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unite (Unite a1 a2) (Unite b1 b2) =
constructTree
  (leafCount (Unite (Unite a1 a2) (Unite b1 b2)) - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk46f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk46f"><span class="kn">Lemma</span> <span class="nf">encodeToNatLtPowerOfTwo</span> (<span class="nv">x</span> : Tree) : encodeToNat x &lt; <span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk470" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk470"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk471" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk471"><span class="nb">pose proof</span> leafCountToLengthEncode x <span class="kr">as</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>length (encodeToList x) = <span class="mi">2</span> * leafCount x - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk472" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk472"><span class="nb">rewrite</span> &lt;- h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>length (encodeToList x) = <span class="mi">2</span> * leafCount x - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encodeToNat x &lt; <span class="mi">2</span> ^ length (encodeToList x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk473" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk473"><span class="nb">unfold</span> encodeToNat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>length (encodeToList x) = <span class="mi">2</span> * leafCount x - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat (encodeToList x) &lt;
<span class="mi">2</span> ^ length (encodeToList x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk474" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk474"><span class="nb">remember</span> (encodeToList x) <span class="kr">as</span> l <span class="nb">eqn</span>:hL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>hL</var><span class="hyp-type"><b>: </b><span>l = encodeToList x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>length l = <span class="mi">2</span> * leafCount x - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat l &lt; <span class="mi">2</span> ^ length l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk475" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk475"><span class="nb">clear</span> hL h x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">listToNat l &lt; <span class="mi">2</span> ^ length l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> l <span class="kr">as</span> [| [|] tail IH]; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk476" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk476"><span class="kn">Lemma</span> <span class="nf">turnIntoOptimalTree</span> (<span class="nv">x</span> : Tree) (<span class="nv">h</span> : optimalTree x) : optimalTree (constructTree (leafCount x - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk477" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk477"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk478" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk478"><span class="nb">induction</span> x <span class="kr">as</span> [x H] <span class="nb">using</span> (well_founded_induction (wf_inverse_image _ nat _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) + encodeToNat x) PeanoNat.Nat.lt_wf_0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk479" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk479"><span class="nb">assert</span> (aid : <span class="kr">forall</span> (<span class="nv">y</span> : Tree) (<span class="nv">h1</span> : score y &gt;= score x) (<span class="nv">h2</span> : encodeToNat y &lt; encodeToNat x) (<span class="nv">h3</span> : leafCount y = leafCount x), <span class="mi">2</span>^(<span class="mi">2</span> * leafCount y - <span class="mi">1</span>) * (leafCount y * leafCount y - score y) + encodeToNat y &lt; <span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) + encodeToNat x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk47a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
score _0 ‚â• score x
‚Üí encodeToNat _0 &lt; encodeToNat x
‚Üí leafCount _0 = leafCount x
‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) * (leafCount _0 * leafCount _0 - score _0) +
encodeToNat _0 &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk47a"><hr></label><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk47b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk47b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk47c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk47c"><span class="nb">intros</span> y h1 h2 h3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount y - <span class="mi">1</span>) *
(leafCount y * leafCount y - score y) + encodeToNat y &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) + encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk47d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk47d"><span class="nb">rewrite</span> !h3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score y) + encodeToNat y &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) + encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk47e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk47e"><span class="nb">remember</span> (<span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)) <span class="kr">as</span> a <span class="nb">eqn</span>:hA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk47f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk47f"><span class="nb">pose proof</span> zeroLtPowerOfTwo (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) <span class="kr">as</span> h4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk480" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk480"><span class="nb">rewrite</span> &lt;- hA <span class="kr">in</span> h4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk481" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk481"><span class="nb">pose proof</span> proj1 (Nat.mul_le_mono_pos_l (leafCount x * leafCount x - score y) (leafCount x * leafCount x - score x) _ h4) <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y ‚â• score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; encodeToNat x</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y)
‚â§ a * (leafCount x * leafCount x - score x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk482" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk482">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
score _0 ‚â• score x
‚Üí encodeToNat _0 &lt; encodeToNat x
‚Üí leafCount _0 = leafCount x
‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) * (leafCount _0 * leafCount _0 - score _0) +
encodeToNat _0 &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk483" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk483"><span class="nb">assert</span> (aid2 : <span class="kr">forall</span> (<span class="nv">y</span> : Tree) (<span class="nv">h1</span> : score y &gt; score x) (<span class="nv">h2</span> : leafCount y = leafCount x), <span class="mi">2</span>^(<span class="mi">2</span> * leafCount y - <span class="mi">1</span>) * (leafCount y * leafCount y - score y) + encodeToNat y &lt; <span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) + encodeToNat x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
score _0 ‚â• score x
‚Üí encodeToNat _0 &lt; encodeToNat x
‚Üí leafCount _0 = leafCount x
‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) * (leafCount _0 * leafCount _0 - score _0) +
encodeToNat _0 &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk484" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
score _0 ‚â• score x
‚Üí encodeToNat _0 &lt; encodeToNat x
‚Üí leafCount _0 = leafCount x
‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) * (leafCount _0 * leafCount _0 - score _0) +
encodeToNat _0 &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) * (leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk484"><hr></label><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk485" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk485">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk486" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk486"><span class="nb">intros</span> y h1 h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount y - <span class="mi">1</span>) *
(leafCount y * leafCount y - score y) + 
encodeToNat y &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) + 
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk487" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk487"><span class="nb">rewrite</span> !h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score y) + 
encodeToNat y &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) + 
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk488" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk488"><span class="nb">remember</span> (<span class="mi">2</span>^(<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)) <span class="kr">as</span> a <span class="nb">eqn</span>:hA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk489" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk489"><span class="nb">pose proof</span> zeroLtPowerOfTwo (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) <span class="kr">as</span> h4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48a" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48a"><span class="nb">rewrite</span> &lt;- hA <span class="kr">in</span> h4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48b"><span class="nb">pose proof</span> scoreUpperBound x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48c"><span class="nb">pose proof</span> scoreUpperBound y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount y * leafCount y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48d"><span class="nb">rewrite</span> h2 <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48e"><span class="nb">pose proof</span> proj1 (Nat.mul_lt_mono_pos_l _ (leafCount x * leafCount x - score y) (leafCount x * leafCount x - score x) h4) <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk48f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk48f"><span class="nb">pose proof</span> encodeToNatLtPowerOfTwo x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk490" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk490"><span class="nb">pose proof</span> encodeToNatLtPowerOfTwo y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount y - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk491" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk491"><span class="nb">rewrite</span> h2 <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk492" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk492"><span class="nb">rewrite</span> &lt;- hA <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk493" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk493"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : a * (leafCount x * leafCount x - score y) + encodeToNat y &lt; a * (leafCount x * leafCount x - score y) + a) <span class="kr">as</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score y) + a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk494" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk494"><span class="nb">rewrite</span> mult_n_Sm <span class="kr">in</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * S (leafCount x * leafCount x - score y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk495" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk495"><span class="nb">pose proof</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : leafCount x * leafCount x - score y &lt; leafCount x * leafCount x - score x) <span class="kr">as</span> step2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * S (leafCount x * leafCount x - score y)</span></span></span><br><span><var>step2</var><span class="hyp-type"><b>: </b><span>leafCount x * leafCount x - score y &lt;
leafCount x * leafCount x - score x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk496" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk496"><span class="nb">rewrite</span> &lt;- Nat.le_succ_l <span class="kr">in</span> step2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * S (leafCount x * leafCount x - score y)</span></span></span><br><span><var>step2</var><span class="hyp-type"><b>: </b><span>S (leafCount x * leafCount x - score y)
‚â§ leafCount x * leafCount x - score x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk497" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk497"><span class="nb">pose proof</span> proj1 (Nat.mul_le_mono_pos_l _ _ _ h4) step2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>hA</var><span class="hyp-type"><b>: </b><span>a = <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  a * (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        a *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>score y &gt; score x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount y = leafCount x</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; a</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score y ‚â§ leafCount x * leafCount x</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) &lt;
a * (leafCount x * leafCount x - score x)</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>encodeToNat x &lt; a</span></span></span><br><span><var>_4</var><span class="hyp-type"><b>: </b><span>encodeToNat y &lt; a</span></span></span><br><span><var>step</var><span class="hyp-type"><b>: </b><span>a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * S (leafCount x * leafCount x - score y)</span></span></span><br><span><var>step2</var><span class="hyp-type"><b>: </b><span>S (leafCount x * leafCount x - score y)
‚â§ leafCount x * leafCount x - score x</span></span></span><br><span><var>_5</var><span class="hyp-type"><b>: </b><span>a * S (leafCount x * leafCount x - score y)
‚â§ a * (leafCount x * leafCount x - score x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * (leafCount x * leafCount x - score y) +
encodeToNat y &lt;
a * (leafCount x * leafCount x - score x) +
encodeToNat x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk498" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk498">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk499" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk499"><span class="nb">destruct</span> (decide (hasRule1 x)) <span class="kr">as</span> [h1 | H1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk49a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk49a"><hr></label><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49b" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49c" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49c"><span class="nb">pose proof</span> rule1_replace_score x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x = score (replaceRule1 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49d" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49d"><span class="nb">pose proof</span> rule1_replace _ h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x = score (replaceRule1 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule1 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49e" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49e"><span class="nb">pose proof</span> rule1_replace_leafCount x <span class="kr">as</span> hCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x = score (replaceRule1 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule1 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule1 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk49f" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk49f"><span class="nb">pose proof</span> H (replaceRule1 x) <span class="kp">ltac</span>:(<span class="nb">pose proof</span> aid (replaceRule1 x) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>); <span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="nb">intros</span> another hLeaf; <span class="nb">pose proof</span> h another <span class="kp">ltac</span>:(<span class="bp">lia</span>); <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule1 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x = score (replaceRule1 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule1 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule1 x)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>optimalTree
  (constructTree (leafCount (replaceRule1 x) - <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- hCount <span class="kr">in</span> *.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a1"><span class="nb">destruct</span> (decide (hasRule2 x)) <span class="kr">as</span> [h1 | H2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk4a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk4a2"><hr></label><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a4"><span class="nb">pose proof</span> rule2_replace_score x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ score (replaceRule2 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a5"><span class="nb">pose proof</span> rule2_replace _ h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ score (replaceRule2 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule2 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a6"><span class="nb">pose proof</span> rule2_replace_leafCount x <span class="kr">as</span> hCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ score (replaceRule2 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule2 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule2 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a7"><span class="nb">pose proof</span> H (replaceRule2 x) <span class="kp">ltac</span>:(<span class="nb">pose proof</span> aid (replaceRule2 x) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>); <span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="nb">intros</span> another hLeaf; <span class="nb">pose proof</span> h another <span class="kp">ltac</span>:(<span class="bp">lia</span>); <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule2 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>score x ‚â§ score (replaceRule2 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>encodeToNat x &gt; encodeToNat (replaceRule2 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule2 x)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span>optimalTree
  (constructTree (leafCount (replaceRule2 x) - <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- hCount <span class="kr">in</span> *.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a8" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4a9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4a9"><span class="nb">destruct</span> (decide (hasRule3 x)) <span class="kr">as</span> [h1 | H3].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk4aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule3 x</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk4aa"><hr></label><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4ab" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4ab">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4ac" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4ac"><span class="nb">pose proof</span> rule3_replace_score x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>hasRule3 x ‚Üí score x &lt; score (replaceRule3 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4ad" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4ad"><span class="nb">pose proof</span> rule3_replace_score _ h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>hasRule3 x ‚Üí score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score (replaceRule3 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4ae" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4ae"><span class="nb">pose proof</span> rule3_replace_leafCount x <span class="kr">as</span> hCount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>hasRule3 x ‚Üí score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule3 x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4af" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4af"><span class="nb">pose proof</span> aid2 (replaceRule3 x) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>hasRule3 x ‚Üí score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule3 x)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount (replaceRule3 x) - <span class="mi">1</span>) *
(leafCount (replaceRule3 x) *
 leafCount (replaceRule3 x) -
 score (replaceRule3 x)) +
encodeToNat (replaceRule3 x) &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b0"><span class="nb">pose proof</span> H (replaceRule3 x) <span class="kp">ltac</span>:(<span class="bp">lia</span>) <span class="kp">ltac</span>:(<span class="nb">intros</span> another hLeaf; <span class="nb">pose proof</span> h another <span class="kp">ltac</span>:(<span class="bp">lia</span>); <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>hasRule3 x</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>hasRule3 x ‚Üí score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span>score x &lt; score (replaceRule3 x)</span></span></span><br><span><var>hCount</var><span class="hyp-type"><b>: </b><span>leafCount x = leafCount (replaceRule3 x)</span></span></span><br><span><var>_2</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount (replaceRule3 x) - <span class="mi">1</span>) *
(leafCount (replaceRule3 x) *
 leafCount (replaceRule3 x) -
 score (replaceRule3 x)) +
encodeToNat (replaceRule3 x) &lt;
<span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
(leafCount x * leafCount x - score x) +
encodeToNat x</span></span></span><br><span><var>_3</var><span class="hyp-type"><b>: </b><span>optimalTree
  (constructTree (leafCount (replaceRule3 x) - <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- hCount <span class="kr">in</span> *.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b1">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule1 x</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule2 x</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>¬¨ hasRule3 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b2"><span class="nb">rewrite</span> Is_true_false <span class="kr">in</span> H1, H2, H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>hasRule1 x = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>hasRule2 x = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b3"><span class="nb">pose proof</span> noThreeRules _ H1 H2 H3 <span class="kr">as</span> d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>hasRule1 x = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>hasRule2 x = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>x = constructTree (leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b4"><span class="nb">rewrite</span> &lt;- d <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
  (leafCount _0 * leafCount _0 - score _0) +
  encodeToNat _0 &lt;
  <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
  (leafCount x * leafCount x - score x) +
  encodeToNat x
  ‚Üí optimalTree _0
    ‚Üí optimalTree
        (constructTree (leafCount _0 - <span class="mi">1</span>))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>aid</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 ‚â• score x
  ‚Üí encodeToNat _0 &lt; encodeToNat x
    ‚Üí leafCount _0 = leafCount x
      ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
        (leafCount _0 * leafCount _0 - score _0) +
        encodeToNat _0 &lt;
        <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
        (leafCount x * leafCount x - score x) +
        encodeToNat x</span></span></span><br><span><var>aid2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">_0</span> : Tree,
  score _0 &gt; score x
  ‚Üí leafCount _0 = leafCount x
    ‚Üí <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount _0 - <span class="mi">1</span>) *
      (leafCount _0 * leafCount _0 - score _0) +
      encodeToNat _0 &lt;
      <span class="mi">2</span> ^ (<span class="mi">2</span> * leafCount x - <span class="mi">1</span>) *
      (leafCount x * leafCount x - score x) +
      encodeToNat x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>hasRule1 x = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>hasRule2 x = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>hasRule3 x = false</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>x = constructTree (leafCount x - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b5"><span class="kn">Lemma</span> <span class="nf">constructTreeIsOptimal</span> (<span class="nv">n</span> : nat) : optimalTree (constructTree n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b7" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b7"><span class="nb">destruct</span> n <span class="kr">as</span> [| n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk4b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk4b8"><hr></label><div class="goal-conclusion">optimalTree (constructTree (S n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4b9" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4b9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4ba" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4ba"><span class="nb">intros</span> x h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) = leafCount x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score x ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4bb" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4bb"><span class="nb">destruct</span> x <span class="kr">as</span> [| a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) = leafCount Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="DisjointSetUnion-v-chk4bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) =
leafCount (Unite a b)</span></span></span><br></div><label class="goal-separator" for="DisjointSetUnion-v-chk4bc"><hr></label><div class="goal-conclusion">score (Unite a b) ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4bd" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4bd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) = leafCount Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score Unit ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4be" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4be"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) = leafCount Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4bf" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4bf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>leafCount (constructTree <span class="mi">0</span>) =
leafCount (Unite a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c0" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c0"><span class="nb">simpl</span> <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = leafCount a + leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c1" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c1"><span class="nb">pose proof</span> oneLeqLeafCount a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = leafCount a + leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c2" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c2"><span class="nb">pose proof</span> oneLeqLeafCount b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = leafCount a + leafCount b</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount a</span></span></span><br><span><var>_1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ leafCount b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">score (Unite a b) ‚â§ score (constructTree <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c3" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c4" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c4"><span class="nb">pose proof</span> getOptimalTree (S n) <span class="kr">as</span> [x [h1 h2]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount x = S (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c5" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c5"><span class="nb">pose proof</span> turnIntoOptimalTree _ h1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount x = S (S n)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>optimalTree (constructTree (leafCount x - <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="DisjointSetUnion-v-chk4c6" style="display: none" type="checkbox"><label class="alectryon-input" for="DisjointSetUnion-v-chk4c6"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">lia</span>) : leafCount x - <span class="mi">1</span> = S n) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Tree</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>optimalTree x</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>leafCount x = S (S n)</span></span></span><br><span><var>_0</var><span class="hyp-type"><b>: </b><span>optimalTree (constructTree (S n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">optimalTree (constructTree (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre></article></body></html>