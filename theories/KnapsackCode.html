<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>KnapsackCode.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> numbers list.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssrmatching_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssreflect_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> CoqCP <span class="kn">Require Import</span> Options Imperative Knapsack.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Generated <span class="kn">Require Import</span> Knapsack.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">state</span> : BlockchainState := <span class="kr">fun</span> <span class="nv">address</span> =&gt;
  <span class="kr">if</span> decide (address = <span class="kp">repeat</span> (<span class="mi">0</span>%Z) <span class="mi">20</span>) <span class="kr">then</span>
    BlockchainContract arrayIndex0 _ (arrayType _ environment0) (arrays _ environment0) <span class="mi">100000</span>%Z (funcdef_0__main (<span class="kr">fun</span> <span class="nv">x</span> =&gt; false) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">0</span>%Z) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kp">repeat</span> <span class="mi">0</span>%Z <span class="mi">20</span>))
  <span class="kr">else</span> ExternallyOwned <span class="mi">0</span>%Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">stateAfterInteractions</span> <span class="nv">arrays</span> <span class="nv">money</span> : BlockchainState := <span class="kr">fun</span> <span class="nv">address</span> =&gt;
  <span class="kr">if</span> decide (address = <span class="kp">repeat</span> (<span class="mi">0</span>%Z) <span class="mi">20</span>) <span class="kr">then</span>
    BlockchainContract arrayIndex0 _ (arrayType _ environment0) arrays (<span class="mi">100000</span>%Z - money) (funcdef_0__main (<span class="kr">fun</span> <span class="nv">x</span> =&gt; false) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">0</span>%Z) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kp">repeat</span> <span class="mi">0</span>%Z <span class="mi">20</span>))
  <span class="kr">else</span> <span class="kr">if</span> decide (address = <span class="kp">repeat</span> (<span class="mi">1</span>%Z) <span class="mi">20</span>) <span class="kr">then</span> ExternallyOwned money <span class="kr">else</span> ExternallyOwned <span class="mi">0</span>%Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to32</span> (<span class="nv">x</span> : nat) := [Z.of_nat (x / (<span class="mi">2</span>^<span class="mi">24</span>)); Z.of_nat (x / (<span class="mi">2</span>^<span class="mi">16</span>) mod <span class="mi">256</span>); Z.of_nat (x / (<span class="mi">2</span>^<span class="mi">8</span>) mod <span class="mi">256</span>); Z.of_nat (x mod <span class="mi">256</span>)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk1"><span class="kn">Lemma</span> <span class="nf">to32Length</span> (<span class="nv">x</span> : nat) : length (to32 x) = <span class="mi">4</span>%nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (to32 x) = <span class="mi">4</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (to32 x) = <span class="mi">4</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk3"><span class="nb">unfold</span> to32.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  [Z.of_nat (x `div` <span class="mi">2</span> ^ <span class="mi">24</span>);
   Z.of_nat ((x `div` <span class="mi">2</span> ^ <span class="mi">16</span>) `mod` <span class="mi">256</span>);
   Z.of_nat ((x `div` <span class="mi">2</span> ^ <span class="mi">8</span>) `mod` <span class="mi">256</span>);
   Z.of_nat (x `mod` <span class="mi">256</span>)] = <span class="mi">4</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">serializeWeights</span> (<span class="nv">items</span> : list (nat * nat)) : list Z :=
  <span class="kr">match</span> items <span class="kr">with</span>
  | [] =&gt; []
  | (weight, _) :: rest =&gt; to32 weight ++ serializeWeights rest
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk4"><span class="kn">Lemma</span> <span class="nf">serializeWeightsLength</span> (<span class="nv">items</span> : list (nat * nat)) : (length (serializeWeights items) = <span class="mi">4</span> * length items)%nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights items) =
(<span class="mi">4</span> * length items)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights items) =
(<span class="mi">4</span> * length items)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk6"><span class="nb">induction</span> items <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights []) = (<span class="mi">4</span> * length [])%nat</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="KnapsackCode-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeWeights tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><label class="goal-separator" for="KnapsackCode-v-chk7"><hr></label><div class="goal-conclusion">length (serializeWeights (head :: tail)) =
(<span class="mi">4</span> * length (head :: tail))%nat</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights []) = (<span class="mi">4</span> * length [])%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeWeights tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights (head :: tail)) =
(<span class="mi">4</span> * length (head :: tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chka"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : length (head :: tail) = (<span class="mi">1</span> + length tail)%nat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeWeights tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights (head :: tail)) =
(<span class="mi">4</span> * (<span class="mi">1</span> + length tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chkb"><span class="nb">destruct</span> head <span class="kr">as</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeWeights tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeWeights ((a, b) :: tail)) =
(<span class="mi">4</span> * (<span class="mi">1</span> + length tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chkc"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeWeights tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S (S (S (length (serializeWeights tail))))) =
S
  (length tail +
   S
     (length tail +
      S (length tail + S (length tail + <span class="mi">0</span>))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">serializeValues</span> (<span class="nv">items</span> : list (nat * nat)) : list Z :=
  <span class="kr">match</span> items <span class="kr">with</span>
  | [] =&gt; []
  | (_, value) :: rest =&gt; to32 value ++ serializeValues rest
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chkd"><span class="kn">Lemma</span> <span class="nf">serializeValuesLength</span> (<span class="nv">items</span> : list (nat * nat)) : (length (serializeValues items) = <span class="mi">4</span> * length items)%nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues items) =
(<span class="mi">4</span> * length items)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues items) =
(<span class="mi">4</span> * length items)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chkf"><span class="nb">induction</span> items <span class="kr">as</span> [| head tail IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues []) = (<span class="mi">4</span> * length [])%nat</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="KnapsackCode-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeValues tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><label class="goal-separator" for="KnapsackCode-v-chk10"><hr></label><div class="goal-conclusion">length (serializeValues (head :: tail)) =
(<span class="mi">4</span> * length (head :: tail))%nat</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk11">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues []) = (<span class="mi">4</span> * length [])%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk12">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeValues tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues (head :: tail)) =
(<span class="mi">4</span> * length (head :: tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk13"><span class="nb">rewrite</span> (<span class="kp">ltac</span>:(<span class="bp">easy</span>) : length (head :: tail) = (<span class="mi">1</span> + length tail)%nat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>head</var><span class="hyp-type"><b>: </b><span>nat * nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeValues tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues (head :: tail)) =
(<span class="mi">4</span> * (<span class="mi">1</span> + length tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk14"><span class="nb">destruct</span> head <span class="kr">as</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeValues tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (serializeValues ((a, b) :: tail)) =
(<span class="mi">4</span> * (<span class="mi">1</span> + length tail))%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk15"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>tail</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>length (serializeValues tail) =
(<span class="mi">4</span> * length tail)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S (S (S (length (serializeValues tail))))) =
S
  (length tail +
   S
     (length tail +
      S (length tail + S (length tail + <span class="mi">0</span>))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">generateData</span> (<span class="nv">items</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : list Z := serializeWeights items ++ serializeValues items ++ to32 limit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk16"><span class="kn">Lemma</span> <span class="nf">dataLength</span> (<span class="nv">items</span> : list (nat * nat)) (<span class="nv">limit</span> : nat) : (length (generateData items limit) = <span class="mi">8</span> * length items + <span class="mi">4</span>%nat)%nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (generateData items limit) =
(<span class="mi">8</span> * length items + <span class="mi">4</span>)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (generateData items limit) =
(<span class="mi">8</span> * length items + <span class="mi">4</span>)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk18"><span class="nb">unfold</span> generateData.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (serializeWeights items ++
   serializeValues items ++ to32 limit) =
(<span class="mi">8</span> * length items + <span class="mi">4</span>)%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="KnapsackCode-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="KnapsackCode-v-chk19"><span class="nb">rewrite</span> -&gt; !app_length, to32Length, serializeValuesLength, serializeWeightsLength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>items</var><span class="hyp-type"><b>: </b><span>list (nat * nat)</span></span></span><br><span><var>limit</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">4</span> * length items + (<span class="mi">4</span> * length items + <span class="mi">4</span>))%nat =
(<span class="mi">8</span> * length items + <span class="mi">4</span>)%nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">start</span> <span class="nv">items</span> <span class="nv">limit</span> := invokeContract (<span class="kp">repeat</span> (<span class="mi">1</span>%Z) <span class="mi">20</span>) (<span class="kp">repeat</span> (<span class="mi">0</span>%Z) <span class="mi">20</span>) <span class="mi">0</span> state state (generateData items limit) <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">extractAnswer</span> (<span class="nv">x</span> : option (list Z * BlockchainState)) : Z :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | Some (answer, _) =&gt; nth <span class="mi">0</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">56</span>) + nth <span class="mi">1</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">48</span>) + nth <span class="mi">2</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">40</span>) + nth <span class="mi">3</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">32</span>) + nth <span class="mi">4</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">24</span>) + nth <span class="mi">5</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">16</span>) + nth <span class="mi">6</span> answer <span class="mi">0</span> * (<span class="mi">2</span>^<span class="mi">8</span>) + nth <span class="mi">7</span> answer <span class="mi">0</span>
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span></pre></article></body></html>