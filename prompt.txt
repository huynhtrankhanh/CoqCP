FROM THESE PIECES OF INFORMATION ABOVE PLEASE FULFILL THE USER REQUEST

MODE FOR CODE GENERATION: BLOCKCHAIN MODE

LANGUAGE FOR CODE GENERATION: “INTERNAL IMPERATIVE LANGUAGE”. DECLINE REQUESTS FOR OTHER LANGUAGES.
<userRequest>
PLEASE REPLACE WITH USER REQUEST
</userRequest>

WARNING: NOT ALL ARITHMETIC OPERATORS ARE SUPPORTED LIKE NORMAL. READ DOCUMENTATION CAREFULLY FOR CAVEATS AND WORKAROUNDS (for example division, comparison)

Here is language documentation:
# Internal imperative language

The CoqCP project now includes a compiler. The compiler compiles an internal imperative language to two files. The first file is a Coq file to be used for program verification. The second file is a Solidity file if blockchain mode is used or C++ file if competitive programming mode is used.

## Using the compiler

Prerequisites: Node.js and npm. Please install both first. Then follow these instructions.

- The compiler is in the `compiler` directory. Switch to that directory.
- Run `npm install` to install dependencies.
- Run `npx tsc --noCheck`. Now compiled JavaScript files are in the `dist` subfolder.
- Now you can use the command line interface. You can pass options to the compiler through arguments or a JSON file.

 - Arguments: 
   For **blockchain mode**:

   - `node dist/cli --blockchain coq_output_file solidity_output_file input_file_1 input_file_2 ... input_file_n`
   - If you want the compiler to recompile on file changes: `node dist/cli --blockchain --watch coq_output_file solidity_output_file input_file_1 input_file_2 ... input_file_n`

     For **competitive programming mode**:

   - `node dist/cli coq_output_file cpp_output_file input_file_1 input_file_2 ... input_file_n`
   - If you want the compiler to recompile on file changes: `node dist/cli --watch coq_output_file cpp_output_file input_file_1 input_file_2 ... input_file_n`

 - JSON file: 
   `node dist/cli ?json json_file_path`

   Here is the schema for the JSON file.

   ```typescript
   type Config =
     | {
         type: 'competitive'
         inputs: string[]
         coqOutput: string
         cppOutput: string
       }
     | {
         type: 'blockchain'
         inputs: string[]
         coqOutput: string
         solidityOutput: string
       }
   ```

## Working on the compiler

To work on the compiler, you will need to have Node.js installed. After that, switch to the `compiler` directory, and run `npm` to install the dependencies.

Then, you will need to run the `tsc` compiler in watch mode. To do this, run `npx tsc -w -p .`. The `tsc` compiler now monitors all changes to the TypeScript files and produces the corresponding files in the `dist` subdirectory.

## Language introduction

The internal imperative language steals JavaScript syntax and interprets the parsed AST differently. As JavaScript syntax is stolen, the internal language is subject to every single JavaScript syntactic rule, including automatic semicolon insertion.

The documentation for this language isn't very precise. I hope you can fill in the gaps by reading the generated Coq and C++ code.

A source file consists of 0 or 1 `environment` block, 0 or 1 `module` line and any number of `procedure` blocks.

Every source file is a module. The `module` line can be placed at the top, at the bottom or between procedures. It declares the name of the module. Its syntax is as follows:

```js
module(ModuleName)
```

Here, `ModuleName` is any valid JavaScript identifier. It must be a JavaScript identifier, not a string. So for example, `module("module name")` is mot allowed.

A program is a collection of modules. Modules can be shared between programs. A program isn't allowed to have two modules of the same name.

If a module doesn't declare its name, it simply doesn't have a name. The module, instead, becomes the main module of the program. A program isn't allowed to have two main modules either.

The entry point of a program is the `"main"` procedure in the main module of the program.

Not having a main module or a `"main"` procedure within the main module doesn't cause a compilation error, the program just doesn't do anything in this case.

The `environment` block can be placed at the top, at the bottom or between procedures.

Here is an example of an `environment` block.

```js
environment({
 fibSeq: array([int32], 100),
 anotherArray: array([int8, int64], 3),
})
```

In the above example, we declare two arrays `fibSeq` and `anotherArray`. `fibSeq` is an array of 100 elements, each element has a type of `[int32]`. `anotherArray` is an array of 3 elements, each element has a type of `[int8, int64]`.

The permitted primitive types are `int8`, `int16`, `int32`, `int64` and `bool`.

Here is an example of a procedure.

```js
procedure('hello', { var1: int8 }, () => {
 // ...
})
```

The first argument is the procedure name. The second argument is an object literal representing local variables for the procedure. The key represents the variable name, and the value represents the primitive type.

Within a procedure, there are several commands.

## Number literal

```js
0
```

```js
1
```

```go
-1
```

```js
998244353
```

Only integers are allowed. Number literals are always interpreted as `int64`.

**In general, numbers are treated as unsigned unless you use a command specifically for signed numbers.** If you write a negative number, it will be silently converted to its unsigned equivalent.

## String literal

```js
'hello'
```

```js
'đi chơi không'
```

```js
'自我解放吧！'
```

String literals can only be used with `range()`.

## Set a local variable

```js
set('variable_name', value)
```

This is a statement and doesn't return.

## Get a local variable

```js
get('variable_name')
```

The return type depends on the variable type.

## Arithmetic

These operators are supported: `+`, `-`, `*`, `|`, `^`, `&`, `~`.

To divide, you can use `divide(x, y)` (unsigned) or `sDivide(x, y)` (signed).

**In general, numbers are treated as unsigned unless you use a command specifically for signed numbers.**

Only the `sDivide` command has overflow. All other commands use wraparound arithmetic.

## Read character

```js
readChar()
```

Returns an `int64`. Return value fits within `int8` range if end of file is not reached. If end of line is reached, `readChar()` returns `int64` `-1`.

## Write character

```js
writeChar(x)
```

Takes a single `int8` as argument.

## Boolean Operators

These operators are allowed: `||`, `&&` and `!`.

## Comparison

`==` and `!=` can be used on both numbers and booleans, provided that the values on both sides are of the same type.

You can use `less(x, y)` (unsigned) and `sLess(x, y)` (signed) to check whether x is less than y. Both x and y must be numbers and of the same type.

## Coercion

You can coerce any boolean or number to a numeric type.

**Booleans:** If you coerce `false`, you get `0`. If you coerce `true`, you get `1`.

The coercion commands are `coerceInt8`, `coerceInt16`, `coerceInt32` and `coerceInt64`. `coerceInt256` is also supported in blockchain mode.

## Get global array element

```js
retrieve("array_name", /* array index */)[/* tuple index */]
```

Tuple index must be a literal number. Array index must be an `int64`.

## Set global array element

```js
store("array_name", /* array index */, [tupleElement1, tupleElement2, /* ... */])
```

Array index must be an `int64`.

## `if`/`else`

```js
if (condition) {
 // ...
} else {
 // ...
}
```

Same syntax as JavaScript. `{}` (curly brackets) are mandatory.

`else if` isn't supported.

## Loop

### Numeric

```js
range(endValue, (counter) => {
 // ...
})
```

`endValue` is an `int64`. The `counter` is also an `int64`. The counter goes from 0 to endValue - 1, similar to `for i in range(x)` in Python.

Within a `range` command, you can use `"break"` (**not `break`**) and `"continue"` (**not `continue`**).

Example:

```js
range(endValue, (counter) => {
 if (less(counter, 5)) {
   ;('break')
 }
 ;('continue')
})
```

### String literal

```js
range('Hello, World!', (x) => {
 writeChar(x)
})
```

Iterates over all bytes of the UTF-8 representation of the string. `x` is of type `int8`. Each byte might or might not represent a character.

Iteration over a string literal isn't supported in blockchain mode because I'm too lazy to implement it. Attempting to do so will not result in a compiler error but will not generate syntactically valid Solidity code. It's actually not difficult to implement, it's just that I don't have the motivation.

## Procedure call

### Within the same module

```js
call('procedure_name', {
 a: 5,
 b: 6,
})
```

When calling a procedure, you can preset some of its local variables. The remaining local variables are initialized to 0 if the variable is numeric and false if the variable is boolean. A procedure call is a statement and doesn't have a return value.

It is only possible to call functions that are already declared. Recursion is not allowed.

### Cross module calls

```js
call(
 moduleName,
 {
   array1: 'arrayA',
   array2: 'arrayB',
 },
 'procedure name',
 { a: 5, b: 6 }
)
```

The first two parameters are the module name and the array mapping, respectively. The module name isn't a string, it is written without quotes. The two remaining variables are the procedure name and the preset variables.

**Array mapping:** When calling a procedure in another module, you have to supply the module with all the arrays it declares in its `environment` block. This creates a mapping between the arrays in the external module and the arrays in the current module. When calling a procedure in another module, that external module can't create arrays on its own.

# Blockchain features

These features can only be used if you use blockchain mode.

In blockchain mode, there are two new types: `address` and `int256`.

## `coerceInt256()`

As mentioned earlier, this command only exists in blockchain mode.

## Get sender

```js
getSender()
```

This returns an `address`.

## Get money (equivalent to `msg.value` in Solidity)

```js
getMoney()
```

This returns an `int256`. It returns the amount of money in wei that is transferred as part of the smart contract call.

## Transfer money

```js
donate(address, money)
```

`address` is of type `address`, `money` is of type `int256`. This call transfers `money` wei to the address.

## Invoke smart contract

```js
invoke(address, money, 'array name', communicationLength)
```

`address` is of type `address`, `money` is of type `int256`, `'array name'` is a string literal, `communicationLength` is an `int64` indicating the length of the array passed to the called smart contract. It can be less than or equal to the actual length of the array. The called smart contract can freely modify the array passed. This call transfers `money` wei to the callee.

At the EVM level, the array is transferred to the callee as calldata and transferred back to the caller as return data.

## Get communication size

```js
communicationSize()
```

Returns an `int64`. This is the size of the array passed to the smart contract in the `invoke()` call.

## Read communication array

```js
retrieve(index)
```

`index` is an `int64`. Returns `int8`.

## Modify communication array

```js
store(index, value)
```

`index` is an `int64`, `value` is an `int8`. Doesn't return.
Here are several example programs:
environment({
 // Global heap array (adjust capacity as needed)
 heap: array([int32], 100000),
 // Global heap size tracker (number of elements currently in the heap)
 heapSize: array([int32], 1),
})

// siftUp moves the element at the given index upward to restore the heap property.
procedure(
 'siftUp',
 {
   index: int32, // parameter: starting index
   currentIndex: int32, // local variable for current index
   parentIndex: int32, // local variable for parent's index
   temp: int32, // local temporary variable for swapping
 },
 () => {
   set('currentIndex', get('index'))
   range(30, (i) => {
     if (get('currentIndex') == coerceInt32(0)) {
       ;('break')
     }
     // Compute parent index as (currentIndex - 1) / 2 (using unsigned division)
     set(
       'parentIndex',
       divide(get('currentIndex') - coerceInt32(1), coerceInt32(2))
     )
     // If the current element is less than its parent, swap them.
     if (
       less(
         retrieve('heap', coerceInt64(get('currentIndex')))[0],
         retrieve('heap', coerceInt64(get('parentIndex')))[0]
       )
     ) {
       set('temp', retrieve('heap', coerceInt64(get('currentIndex')))[0])
       store('heap', coerceInt64(get('currentIndex')), [
         retrieve('heap', coerceInt64(get('parentIndex')))[0],
       ])
       store('heap', coerceInt64(get('parentIndex')), [get('temp')])
       set('currentIndex', get('parentIndex'))
     } else {
       ;('break')
     }
   })
 }
)

// siftDown moves the element at the given index downward to restore the heap property.
procedure(
 'siftDown',
 {
   index: int32, // parameter: starting index
   currentIndex: int32, // local variable for current index
   leftChild: int32, // local variable for left child index
   rightChild: int32, // local variable for right child index
   smallestIndex: int32, // local variable to track the smallest among current and children
   temp: int32, // local temporary variable for swapping
 },
 () => {
   set('currentIndex', get('index'))
   if (retrieve('heapSize', 0)[0] != coerceInt32(0)) {
     range(30, (i) => {
       // Calculate child indices
       set('leftChild', get('currentIndex') * coerceInt32(2) + coerceInt32(1))
       set('rightChild', get('currentIndex') * coerceInt32(2) + coerceInt32(2))
       // Assume current index is the smallest.
       set('smallestIndex', get('currentIndex'))
       // Check left child.
       if (less(get('leftChild'), retrieve('heapSize', 0)[0])) {
         if (
           less(
             retrieve('heap', coerceInt64(get('leftChild')))[0],
             retrieve('heap', coerceInt64(get('smallestIndex')))[0]
           )
         ) {
           set('smallestIndex', get('leftChild'))
         }
       }
       // Check right child.
       if (less(get('rightChild'), retrieve('heapSize', 0)[0])) {
         if (
           less(
             retrieve('heap', coerceInt64(get('rightChild')))[0],
             retrieve('heap', coerceInt64(get('smallestIndex')))[0]
           )
         ) {
           set('smallestIndex', get('rightChild'))
         }
       }
       // If the smallest is the current element, then the heap property holds.
       if (get('smallestIndex') == get('currentIndex')) {
         ;('break')
       }
       // Otherwise, swap the current element with the smallest child.
       set('temp', retrieve('heap', coerceInt64(get('currentIndex')))[0])
       store('heap', coerceInt64(get('currentIndex')), [
         retrieve('heap', coerceInt64(get('smallestIndex')))[0],
       ])
       store('heap', coerceInt64(get('smallestIndex')), [get('temp')])
       set('currentIndex', get('smallestIndex'))
     })
   }
 }
)

// insert adds a new element into the heap.
procedure(
 'insert',
 {
   value: int32, // parameter: the value to insert
   index: int32, // local variable for index where value is inserted
 },
 () => {
   // Place new value at the end of the heap.
   store('heap', coerceInt64(retrieve('heapSize', 0)[0]), [get('value')])
   // Increase the heap size.
   store('heapSize', 0, [retrieve('heapSize', 0)[0] + coerceInt32(1)])
   // Compute the index of the newly inserted element.
   set('index', retrieve('heapSize', 0)[0] - coerceInt32(1))
   // Restore the heap property.
   call('siftUp', { index: get('index') })
 }
)

// pop removes the minimum element (at the root) from the heap.
procedure(
 'pop',
 {
   index: int32, // local variable for index computations
   temp: int32, // local temporary variable for swapping
 },
 () => {
   if (retrieve('heapSize', 0)[0] != coerceInt32(0)) {
     // Set index to the last element.
     set('index', retrieve('heapSize', 0)[0] - coerceInt32(1))
     // Swap the root with the last element.
     set('temp', retrieve('heap', 0)[0])
     store('heap', 0, [retrieve('heap', coerceInt64(get('index')))[0]])
     store('heap', coerceInt64(get('index')), [get('temp')])
     // Decrement the heap size.
     store('heapSize', 0, [retrieve('heapSize', 0)[0] - coerceInt32(1)])
     // Restore the heap property from the root.
     call('siftDown', { index: coerceInt32(0) })
   }
 }
)

procedure('main', { current: int32, sum: int64 }, () => {
 range(divide(communicationSize(), 4), (i) => {
   set(
     'current',
     coerceInt32(retrieve(i * 4)) * coerceInt32(16777216) +
       coerceInt32(retrieve(i * 4 + 1)) * coerceInt32(65536) +
       coerceInt32(retrieve(i * 4 + 2)) * coerceInt32(256) +
       coerceInt32(retrieve(i * 4 + 3))
   )
   if (retrieve('heapSize', 0)[0] != coerceInt32(0)) {
     if (!less(get('current'), retrieve('heap', 0)[0])) {
       set(
         'sum',
         get('sum') + coerceInt64(get('current') - retrieve('heap', 0)[0])
       )
       call('pop', {})
       call('insert', { value: get('current') })
     }
     call('insert', { value: get('current') })
   }
 })
 store(0, coerceInt8(divide(get('sum'), coerceInt64(72057594037927936)))) // Byte 7 (most significant byte)
 store(
   1,
   coerceInt8(
     divide(get('sum'), coerceInt64(281474976710656)) % coerceInt64(256)
   )
 ) // Byte 6
 store(
   2,
   coerceInt8(
     divide(get('sum'), coerceInt64(1099511627776)) % coerceInt64(256)
   )
 ) // Byte 5
 store(
   3,
   coerceInt8(divide(get('sum'), coerceInt64(4294967296)) % coerceInt64(256))
 ) // Byte 4
 store(
   4,
   coerceInt8(divide(get('sum'), coerceInt64(16777216)) % coerceInt64(256))
 ) // Byte 3
 store(
   5,
   coerceInt8(divide(get('sum'), coerceInt64(65536)) % coerceInt64(256))
 ) // Byte 2
 store(6, coerceInt8(divide(get('sum'), coerceInt64(256)) % coerceInt64(256))) // Byte 1
 store(7, coerceInt8(get('sum') % coerceInt64(256))) // Byte 0 (least significant byte)
})
Another program
environment({
 current: array([int32], 1),
 count: array([int32], 1),
 scratchpad: array([int8], 1024),
})

procedure('main', { what: int32, absolute: address }, () => {
 // extract number from calldata
 set(
   'what',
   (coerceInt32(retrieve(0)) << coerceInt32(24)) +
     (coerceInt32(retrieve(1)) << coerceInt32(16)) +
     (coerceInt32(retrieve(2)) << coerceInt32(8)) +
     coerceInt32(retrieve(3))
 )

 if (retrieve('count', 0)[0] == coerceInt32(0)) {
   store('current', 0, [get('what')])
 }

 if (get('what') == retrieve('current', 0)[0]) {
   store('count', 0, [retrieve('count', 0)[0] + coerceInt32(1)])
 } else {
   store('count', 0, [retrieve('count', 0)[0] - coerceInt32(1)])
 }

 store(0, coerceInt8(retrieve('count', 0)[0] >> coerceInt32(24)))
 store(
   1,
   coerceInt8((retrieve('count', 0)[0] >> coerceInt32(16)) & coerceInt32(255))
 )
 store(
   2,
   coerceInt8((retrieve('count', 0)[0] >> coerceInt32(8)) & coerceInt32(255))
 )
 divide(3, 5)
 sDivide(3, 5)
 store(3, coerceInt8(retrieve('count', 0)[0] & coerceInt32(255)))

 donate(get('absolute'), coerceInt256(2000))
 invoke(get('absolute'), coerceInt256(2000), 'scratchpad', coerceInt64(1024))
 invoke(getSender(), getMoney(), 'scratchpad', coerceInt64(1024))
 invoke(
   address(
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0),
     coerceInt8(0)
   ),
   getMoney(),
   'scratchpad',
   coerceInt64(1024)
 )
})
Here is internal AST representation:
import acorn, { ExtendNode } from 'acorn'
import * as ESTree from 'estree'

export type PrimitiveType =
  | 'bool'
  | 'int8'
  | 'int16'
  | 'int32'
  | 'int64'
  | 'int256'
  | 'address'

export interface ArrayDeclaration {
  itemTypes: PrimitiveType[]
  length: {
    type: 'literal'
    valueType: 'number'
    raw: string
    location: Location
  }
}

export interface Environment {
  arrays: Map<string, ArrayDeclaration>
}

export interface Variable {
  type: PrimitiveType
}

export type BinaryOp =
  | 'add'
  | 'subtract'
  | 'multiply'
  | 'mod'
  | 'bitwise or'
  | 'bitwise xor'
  | 'bitwise and'
  | 'boolean and'
  | 'boolean or'
  | 'shift right'
  | 'shift left'
  | 'equal'
  | 'noteq'

export type LocalBinder = {
  type: 'local binder'
  name: string
  location: Location
}
export type ValueType =
  | LocalBinder
  | {
      type: 'literal'
      valueType: 'number' | 'boolean' | 'string'
      raw: string
      location: Location
    }
  | Instruction

const castToInstruction = (x: ValueType): Instruction | undefined =>
  x.type === 'local binder' || x.type === 'literal' ? undefined : x

export interface BinaryOperationInstruction {
  type: 'binaryOp'
  operator: BinaryOp
  left: ValueType
  right: ValueType
}

export type UnaryOp = 'minus' | 'plus' | 'bitwise not' | 'boolean not'

export interface UnaryOperationInstruction {
  type: 'unaryOp'
  operator: UnaryOp
  value: ValueType
}

export const COMMUNICATION = Symbol('communication')

export type Instruction = (
  | { type: 'get'; name: string }
  | {
      type: 'set'
      name: string
      value: ValueType
    }
  | {
      type: 'store'
      name: string
      index: ValueType
      tuple: ValueType[]
    }
  | {
      type: 'store'
      name: typeof COMMUNICATION
      index: ValueType
      value: ValueType
    }
  | { type: 'retrieve'; name: string | typeof COMMUNICATION; index: ValueType }
  | { type: 'communication area size' }
  | {
      type: 'invoke'
      address: ValueType
      money: ValueType
      array: string
      communicationSize: ValueType
    }
  | { type: 'donate'; address: ValueType; money: ValueType }
  | { type: 'get sender' }
  | { type: 'get money' }
  | {
      type: 'range'
      end: ValueType
      loopVariable: string
      loopBody: Instruction[]
    }
  | { type: 'readChar' }
  | { type: 'writeChar'; value: ValueType }
  | BinaryOperationInstruction
  | UnaryOperationInstruction
  | {
      type: 'subscript'
      value: ValueType
      index: ValueType
    }
  | {
      type: 'condition'
      condition: ValueType
      body: Instruction[]
      alternate: Instruction[]
    }
  | {
      type: 'sDivide'
      left: ValueType
      right: ValueType
    }
  | {
      type: 'divide'
      left: ValueType
      right: ValueType
    }
  | {
      type: 'coerceInt8'
      value: ValueType
    }
  | {
      type: 'coerceInt16'
      value: ValueType
    }
  | {
      type: 'coerceInt32'
      value: ValueType
    }
  | {
      type: 'coerceInt64'
      value: ValueType
    }
  | {
      type: 'coerceInt256'
      value: ValueType
    }
  | { type: 'less'; left: ValueType; right: ValueType }
  | { type: 'sLess'; left: ValueType; right: ValueType }
  | {
      type: 'call'
      procedure: string
      presetVariables: Map<string, ValueType>
    }
  | {
      type: 'cross module call'
      procedure: string
      module: string
      presetVariables: Map<string, ValueType>
      // key is name of the array of the called procedure's module
      arrayMapping: Map<string, string>
    }
  | {
      type: 'break' | 'continue' | 'flush'
    }
  | { type: 'construct address'; bytes: ValueType[] }
) & { location: Location }

export class ParseError extends Error {
  constructor(...args: string[] | undefined[]) {
    super(...args)
    this.name = 'ParseError'
  }
}

export type Location = {
  start: { line: number; column: number }
  end: { line: number; column: number }
}

const formatLocation = ({ start, end }: Location): string =>
  `${start.line}:${start.column}-${end.line}:${end.column}`

export interface Procedure {
  name: string
  variables: Map<string, Variable>
  body: Instruction[]
  nameLocation: Location
}

export class CoqCPAST {
  environment: Environment | null = null
  procedures: Procedure[] = []
  moduleName: string = ''
  moduleNameLocation: Location | null = null
}
Here is code validator:
import { PairMap } from './PairMap'
import { consumeNever } from './consumeNever'
import { sortModules, validateCyclicDependencies } from './dependencyGraph'
import {
  ValueType,
  Procedure,
  PrimitiveType,
  CoqCPAST,
  Location,
  COMMUNICATION,
} from './parse'

export type ValidationError =
  | ((
      | {
          type:
            | 'binary expression expects numeric'
            | 'instruction expects numeric'
          actualType1: PrimitiveType | PrimitiveType[] | 'string'
          actualType2: PrimitiveType | PrimitiveType[] | 'string'
        }
      | {
          type: 'binary expression expects boolean'
          actualType1: PrimitiveType | PrimitiveType[] | 'string'
          actualType2: PrimitiveType | PrimitiveType[] | 'string'
        }
      | {
          type: 'binary expression type mismatch' | 'instruction type mismatch'
          actualType1: PrimitiveType | PrimitiveType[] | 'string'
          actualType2: PrimitiveType | PrimitiveType[] | 'string'
        }
      | { type: 'expression no statement' }
      | { type: 'procedure not found'; name: string }
      | { type: 'module not found'; name: string }
      | { type: 'variable not present'; variables: string[] }
      | {
          type: 'variable type mismatch'
          expectedType: PrimitiveType | PrimitiveType[] | 'string'
          actualType: PrimitiveType | PrimitiveType[] | 'string'
        }
      | {
          type: 'condition must be boolean'
          actualType: PrimitiveType | PrimitiveType[] | 'string'
        }
      | { type: 'no surrounding range command' }
      | { type: 'undefined variable' | 'undefined binder' }
      | { type: 'not representable int64' }
      | { type: 'bad number literal' }
      | { type: 'range end must be int64 or string' }
      | {
          type:
            | 'instruction expects int8'
            | 'instruction expects int64'
            | 'instruction expects address'
            | 'instruction expects int256'
            | 'instruction expects tuple'
            | 'instruction expects address or tuple'
        }
      | { type: 'instruction expects [int8] array' }
      | { type: 'instruction only available in blockchain environment' }
      | { type: 'instruction not available in blockchain environment' }
      | { type: 'undefined array' }
      | { type: 'index out of bounds' }
      | {
          type:
            | 'unary operator expects numeric'
            | "unary operator can't operate on tuples"
            | "unary operator can't operate on strings"
            | "unary operator can't operate on addresses"
            | 'unary operator expects boolean'
        }
      | { type: "array length can't be less than 1" }
      | { type: 'string not allowed' }
      | { type: 'call implicated in cycle' }
      | { type: 'must specify all arrays' }
      | {
          type: 'array shape mismatch'
          procedureModuleArrayShape: PrimitiveType[]
          currentModuleArrayShape: PrimitiveType[]
        }
      | {
          type:
            | 'array shape mismatch'
            | "array doesn't exist in procedure module"
          procedureModuleArray: string
        }
      | {
          type: "array doesn't exist in current module"
          currentModuleArray: string
        }
      | { type: 'duplicate procedure'; procedureName: string }
      | { type: 'index must be a number literal' }
    ) & { location: Location & { moduleName: string } })
  | { type: 'duplicate module'; module: CoqCPAST; moduleName: string }

export const isNumeric = (
  x: string | PrimitiveType[]
): x is 'int8' | 'int16' | 'int32' | 'int64' | 'int256' => {
  return (
    x === 'int8' ||
    x === 'int16' ||
    x === 'int32' ||
    x === 'int64' ||
    x === 'int256'
  )
}

export const sortAndValidateAST = (
  modules: CoqCPAST[],
  blockchain: boolean
): ValidationError[] => {
  const sortedModules = sortModules(modules)
  return validateAST(sortedModules, blockchain)
}

export const validateAST = (
  sortedModules: CoqCPAST[],
  blockchain: boolean
): ValidationError[] => {
  // Check for duplicate modules
  {
    const errors: ValidationError[] = []
    const names = sortedModules.map((x) => x.moduleName).sort()
    const mapNameToModule = new Map<string, CoqCPAST[]>()
    sortedModules.map((x) => {
      const array = mapNameToModule.get(x.moduleName)
      if (array === undefined) mapNameToModule.set(x.moduleName, [x])
      else array.push(x)
    })
    const n = names.length
    let cursor = 0
    while (cursor !== n) {
      let next = cursor
      while (next !== n && names[next] === names[cursor]) next++
      if (next - cursor > 1) {
        for (const module of mapNameToModule.get(names[cursor])!)
          errors.push({
            type: 'duplicate module',
            module,
            moduleName: names[cursor],
          })
      }
      cursor = next
    }
    if (errors.length) return errors
  }

  const cyclicDependencyCheck = validateCyclicDependencies(sortedModules)
  if (cyclicDependencyCheck.length) return cyclicDependencyCheck

  const crossModuleProcedureMap = new PairMap<string, string, Procedure>()
  const seenModules = new Map<string, CoqCPAST>()

  const errors: ValidationError[] = []

  for (const currentModule of sortedModules) {
    const { environment, procedures, moduleName } = currentModule
    seenModules.set(moduleName, currentModule)
    if (environment !== null) {
      for (const [key, array] of (environment?.arrays || new Map()).entries()) {
        const raw = array.length.raw
        if (raw !== '0' && !/^[+-]?[1-9]\d*$/.test(raw)) {
          errors.push({
            type: 'bad number literal',
            location: { ...array.length.location, moduleName },
          })
          environment.arrays.delete(key)
          continue
        }
        const evaluated = BigInt(raw)
        if (evaluated < -(2n ** 63n) || evaluated >= 2n ** 64n) {
          errors.push({
            type: 'not representable int64',
            location: { ...array.length.location, moduleName },
          })
          environment.arrays.delete(key)
          continue
        }
        if (evaluated < 1n) {
          errors.push({
            type: "array length can't be less than 1",
            location: { ...array.length.location, moduleName },
          })
          environment.arrays.delete(key)
          continue
        }
      }
    }
    const procedureMap = new Map<string, Procedure>()
    for (const procedure of procedures) {
      if (procedureMap.has(procedure.name)) {
        errors.push({
          type: 'duplicate procedure',
          procedureName: procedure.name,
          location: { ...procedure.nameLocation, moduleName },
        })
        continue
      }
      type Type =
        | PrimitiveType
        | 'string'
        | 'statement'
        | 'illegal'
        | PrimitiveType[]
      let hasSurroundingRangeCommand = false
      const presentBinderType = new Map<string, 'int64' | 'int8'>()
      const dfs = (instruction: ValueType): Type => {
        switch (instruction.type) {
          case 'binaryOp': {
            switch (instruction.operator) {
              case 'add':
              case 'subtract':
              case 'multiply':
              case 'mod':
              case 'bitwise or':
              case 'bitwise xor':
              case 'bitwise and':
              case 'shift left':
              case 'shift right': {
                const leftType = dfs(instruction.left)
                const rightType = dfs(instruction.right)
                if (leftType === rightType && isNumeric(leftType))
                  return leftType
                else {
                  if (leftType === 'illegal' || rightType === 'illegal')
                    return 'illegal'
                  if (leftType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.left.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (rightType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.right.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (!isNumeric(leftType) || !isNumeric(rightType)) {
                    errors.push({
                      type: 'binary expression expects numeric',
                      actualType1: leftType,
                      actualType2: rightType,
                      location: { ...instruction.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (leftType !== rightType) {
                    errors.push({
                      type: 'binary expression type mismatch',
                      actualType1: leftType,
                      actualType2: rightType,
                      location: { ...instruction.location, moduleName },
                    })
                    return 'illegal'
                  }
                  return 'illegal'
                }
              }
              case 'equal':
              case 'noteq': {
                const leftType = dfs(instruction.left)
                const rightType = dfs(instruction.right)
                if (
                  leftType === rightType &&
                  (isNumeric(leftType) ||
                    leftType === 'bool' ||
                    leftType === 'address')
                )
                  return 'bool'
                else {
                  if (leftType === 'illegal' || rightType === 'illegal')
                    return 'illegal'
                  if (leftType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.left.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (rightType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.right.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (leftType !== rightType) {
                    errors.push({
                      type: 'binary expression type mismatch',
                      actualType1: leftType,
                      actualType2: rightType,
                      location: { ...instruction.location, moduleName },
                    })
                    return 'illegal'
                  }
                  return 'illegal'
                }
              }
              case 'boolean and':
              case 'boolean or': {
                const leftType = dfs(instruction.left)
                const rightType = dfs(instruction.right)
                if (leftType === rightType && leftType === 'bool')
                  return leftType
                else {
                  if (leftType === 'illegal' || rightType === 'illegal')
                    return 'illegal'
                  if (leftType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.left.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (rightType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...instruction.right.location, moduleName },
                    })
                    return 'illegal'
                  }
                  if (leftType !== 'bool' || rightType !== 'bool') {
                    errors.push({
                      type: 'binary expression expects boolean',
                      actualType1: leftType,
                      actualType2: rightType,
                      location: { ...instruction.location, moduleName },
                    })
                    return 'illegal'
                  }
                  return 'illegal'
                }
              }
            }
          }
          case 'break': {
            if (!hasSurroundingRangeCommand) {
              errors.push({
                type: 'no surrounding range command',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'call':
            function validateCall(
              procedure: Procedure,
              presetVariables: Map<string, ValueType>,
              location: Location
            ): 'statement' | 'illegal' {
              const { variables } = procedure

              const notPresent = [...presetVariables.keys()].filter(
                (x) => variables.get(x) === undefined
              )
              if (notPresent.length !== 0) {
                errors.push({
                  type: 'variable not present',
                  variables: notPresent,
                  location: { ...location, moduleName },
                })
                return 'illegal'
              }

              let typeMismatch = false

              for (const [variableName, { type }] of variables.entries()) {
                const presetValue = presetVariables.get(variableName)
                if (presetValue === undefined) continue
                const actualType = dfs(presetValue)
                if (type !== actualType) {
                  typeMismatch = true
                  if (actualType === 'statement') {
                    errors.push({
                      type: 'expression no statement',
                      location: { ...presetValue.location, moduleName },
                    })
                  } else if (actualType !== 'illegal') {
                    errors.push({
                      type: 'variable type mismatch',
                      actualType,
                      expectedType: type,
                      location: { ...presetValue.location, moduleName },
                    })
                  }
                }
              }

              if (typeMismatch) return 'illegal'
              return 'statement'
            }
            {
              const {
                procedure: procedureName,
                presetVariables,
                location,
              } = instruction
              const procedure = procedureMap.get(procedureName)
              if (procedure === undefined) {
                errors.push({
                  type: 'procedure not found',
                  name: procedureName,
                  location: { ...location, moduleName },
                })
                return 'illegal'
              }
              return validateCall(procedure, presetVariables, location)
            }
          case 'cross module call': {
            const {
              arrayMapping,
              procedure: procedureName,
              presetVariables,
              location,
              module: procedureModuleName,
            } = instruction
            if (!seenModules.has(procedureModuleName)) {
              errors.push({
                type: 'module not found',
                name: procedureModuleName,
                location: { ...location, moduleName },
              })
              return 'illegal'
            }

            const procedure = crossModuleProcedureMap.get([
              procedureModuleName,
              procedureName,
            ])

            if (procedure === undefined) {
              errors.push({
                type: 'procedure not found',
                name: procedureName,
                location: { ...location, moduleName },
              })
              return 'illegal'
            }

            const basicCheck = validateCall(
              procedure,
              presetVariables,
              location
            )

            if (basicCheck === 'illegal') return 'illegal'

            const procedureModule = seenModules.get(procedureModuleName)!

            if (
              arrayMapping.size <
              (procedureModule.environment?.arrays.size ?? 0)
            ) {
              errors.push({
                type: 'must specify all arrays',
                location: { ...location, moduleName },
              })
              return 'illegal'
            }

            for (const [
              procedureModuleArray,
              currentModuleArray,
            ] of arrayMapping.entries()) {
              const procedureModuleArrayDeclaration =
                procedureModule.environment?.arrays.get(procedureModuleArray)
              const currentModuleArrayDeclaration =
                currentModule.environment?.arrays.get(currentModuleArray)
              if (procedureModuleArrayDeclaration === undefined) {
                errors.push({
                  type: "array doesn't exist in procedure module",
                  procedureModuleArray,
                  location: { ...location, moduleName },
                })
                return 'illegal'
              }
              if (currentModuleArrayDeclaration === undefined) {
                errors.push({
                  type: "array doesn't exist in current module",
                  currentModuleArray,
                  location: { ...location, moduleName },
                })
                return 'illegal'
              }
              if (
                currentModuleArrayDeclaration.itemTypes.length !==
                  procedureModuleArrayDeclaration.itemTypes.length ||
                currentModuleArrayDeclaration.itemTypes.some(
                  (element, index) =>
                    procedureModuleArrayDeclaration.itemTypes[index] !== element
                )
              ) {
                errors.push({
                  type: 'array shape mismatch',
                  procedureModuleArrayShape:
                    procedureModuleArrayDeclaration.itemTypes,
                  currentModuleArrayShape:
                    currentModuleArrayDeclaration.itemTypes,
                  location: { ...location, moduleName },
                })
                return 'illegal'
              }
            }

            return 'statement'
          }
          case 'coerceInt256':
          case 'coerceInt16':
          case 'coerceInt32':
          case 'coerceInt64':
          case 'coerceInt8': {
            const type = dfs(instruction.value)
            if (type === 'illegal') return 'illegal'
            if (type === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return instruction.type === 'coerceInt16'
              ? 'int16'
              : instruction.type === 'coerceInt32'
                ? 'int32'
                : instruction.type === 'coerceInt64'
                  ? 'int64'
                  : instruction.type === 'coerceInt256'
                    ? 'int256'
                    : 'int8'
          }
          case 'condition': {
            const { alternate, body, condition, location } = instruction
            if (alternate.map(dfs).includes('illegal')) return 'illegal'
            if (body.map(dfs).includes('illegal')) return 'illegal'
            const conditionType = dfs(condition)
            if (conditionType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...location, moduleName },
              })
              return 'illegal'
            }
            if (conditionType === 'illegal') return 'illegal'
            if (conditionType !== 'bool') {
              errors.push({
                type: 'condition must be boolean',
                actualType: conditionType,
                location: { ...location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'continue': {
            if (!hasSurroundingRangeCommand) {
              errors.push({
                type: 'no surrounding range command',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'divide':
          case 'sDivide':
          case 'less':
          case 'sLess': {
            const { left, right } = instruction
            const leftType = dfs(left)
            const rightType = dfs(right)
            if (leftType === 'illegal' || rightType === 'illegal')
              return 'illegal'
            if (leftType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...left.location, moduleName },
              })
              return 'illegal'
            }
            if (rightType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...right.location, moduleName },
              })
              return 'illegal'
            }
            if (!isNumeric(leftType) || !isNumeric(rightType)) {
              errors.push({
                type: 'instruction expects numeric',
                location: { ...instruction.location, moduleName },
                actualType1: leftType,
                actualType2: rightType,
              })
              return 'illegal'
            }
            if (leftType !== rightType) {
              errors.push({
                type: 'instruction type mismatch',
                location: { ...instruction.location, moduleName },
                actualType1: leftType,
                actualType2: rightType,
              })
              return 'illegal'
            }
            if (instruction.type === 'divide' || instruction.type === 'sDivide')
              return leftType
            else if (
              instruction.type === 'less' ||
              instruction.type === 'sLess'
            )
              return 'bool'
          }
          case 'flush': {
            if (blockchain) {
              errors.push({
                type: 'instruction not available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'get': {
            const { name } = instruction
            const variable = procedure.variables.get(name)
            if (variable === undefined) {
              errors.push({
                type: 'undefined variable',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return variable.type
          }
          case 'literal': {
            if (instruction.valueType === 'boolean') return 'bool'
            else if (instruction.valueType === 'string') return 'string'
            else if (instruction.valueType === 'number') {
              if (
                instruction.raw !== '0' &&
                !/^[+-]?[1-9]\d*$/.test(instruction.raw)
              ) {
                errors.push({
                  type: 'bad number literal',
                  location: { ...instruction.location, moduleName },
                })
                return 'illegal'
              }
              const evaluated = BigInt(instruction.raw)
              if (evaluated < -(2n ** 63n) || evaluated >= 2n ** 64n) {
                errors.push({
                  type: 'not representable int64',
                  location: { ...instruction.location, moduleName },
                })
                return 'illegal'
              }
              return 'int64'
            }
            return consumeNever(instruction.valueType)
          }
          case 'local binder': {
            const { name } = instruction
            const binderType = presentBinderType.get(name)
            if (binderType === undefined) {
              errors.push({
                type: 'undefined binder',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return binderType
          }
          case 'range': {
            const { end, loopBody, loopVariable } = instruction
            const endType = dfs(end)
            if (endType === 'illegal') return 'illegal'
            if (endType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (endType !== 'int64' && endType !== 'string') {
              errors.push({
                type: 'range end must be int64 or string',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            const previousHasSurroundingRangeCommand =
              hasSurroundingRangeCommand
            hasSurroundingRangeCommand = true
            const binderTypeBefore = presentBinderType.get(loopVariable)
            presentBinderType.set(
              loopVariable,
              endType === 'string' ? 'int8' : 'int64'
            )
            const result = loopBody.map(dfs).includes('illegal')
              ? 'illegal'
              : 'statement'
            hasSurroundingRangeCommand = previousHasSurroundingRangeCommand
            if (binderTypeBefore === undefined)
              presentBinderType.delete(loopVariable)
            else presentBinderType.set(loopVariable, binderTypeBefore)
            return result
          }
          case 'readChar': {
            if (blockchain) {
              errors.push({
                type: 'instruction not available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'int64'
          }
          case 'writeChar': {
            if (blockchain) {
              errors.push({
                type: 'instruction not available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            const type = dfs(instruction.value)
            if (type === 'illegal') return 'illegal'
            if (type === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (type !== 'int8') {
              errors.push({
                type: 'instruction expects int8',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'retrieve': {
            const { index, name } = instruction
            const type = dfs(index)
            if (type === 'illegal') return 'illegal'
            if (type === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (type !== 'int64') {
              errors.push({
                type: 'instruction expects int64',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (name === COMMUNICATION) {
              if (!blockchain) {
                errors.push({
                  type: 'instruction only available in blockchain environment',
                  location: { ...instruction.location, moduleName },
                })
                return 'illegal'
              }
              return 'int8'
            }
            const array = environment?.arrays.get(name)
            if (array === undefined) {
              errors.push({
                type: 'undefined array',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            // unfortunately, this step isn't too concerned with bounds checking
            // please fire up Coq
            return array.itemTypes
          }
          case 'set': {
            const { name, value } = instruction
            const actualType = dfs(value)
            const expectedType = procedure.variables.get(name)?.type
            if (expectedType === undefined) {
              errors.push({
                type: 'undefined variable',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (actualType === 'illegal') return 'illegal'
            if (actualType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (expectedType !== actualType) {
              errors.push({
                type: 'variable type mismatch',
                expectedType,
                actualType,
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'statement'
          }
          case 'store': {
            const { index, name } = instruction
            const indexType = dfs(index)
            let invalid = false
            if (indexType === 'illegal') return 'illegal'
            if (indexType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              invalid = true
            }
            if (indexType !== 'int64') {
              errors.push({
                type: 'instruction expects int64',
                location: { ...instruction.location, moduleName },
              })
              invalid = true
            }
            if (name === COMMUNICATION) {
              if (!blockchain) {
                errors.push({
                  type: 'instruction only available in blockchain environment',
                  location: { ...instruction.location, moduleName },
                })
                return 'illegal'
              }
              if (invalid) return 'illegal'
              const valueType = dfs(instruction.value)
              if (valueType === 'illegal') return 'illegal'
              if (valueType === 'statement') {
                errors.push({
                  type: 'expression no statement',
                  location: { ...instruction.value.location, moduleName },
                })
                return 'illegal'
              }
              if (valueType !== 'int8') {
                errors.push({
                  type: 'instruction expects int8',
                  location: { ...instruction.value.location, moduleName },
                })
                return 'illegal'
              }
              return 'statement'
            }
            const { tuple } = instruction
            const actualType = tuple.map(dfs)
            const filterNotPermissible = (x: Type[]): PrimitiveType[] =>
              x.filter(
                (x): x is PrimitiveType =>
                  x !== 'illegal' && x !== 'statement' && x !== 'string'
              )
            if (actualType.includes('illegal')) return 'illegal'
            for (const [index, type] of actualType.entries()) {
              if (type === 'statement') {
                errors.push({
                  type: 'expression no statement',
                  location: { ...tuple[index].location, moduleName },
                })
              }
              if (type === 'string') {
                errors.push({
                  type: 'string not allowed',
                  location: { ...tuple[index].location, moduleName },
                })
              }
            }
            if (actualType.includes('statement')) return 'illegal'
            const coercedActualType = filterNotPermissible(actualType)
            const elementType = environment?.arrays.get(name)?.itemTypes
            if (elementType === undefined) {
              errors.push({
                type: 'undefined array',
                location: { ...instruction.location, moduleName },
              })
              invalid = true
              return 'illegal'
            }
            if (tuple.length !== elementType.length) {
              errors.push({
                type: 'variable type mismatch',
                expectedType: elementType,
                actualType: coercedActualType,
                location: { ...instruction.location, moduleName },
              })
              invalid = true
            }
            for (const [index, type] of actualType.entries()) {
              if (type !== elementType[index]) {
                errors.push({
                  type: 'variable type mismatch',
                  expectedType: elementType,
                  actualType: coercedActualType,
                  location: { ...instruction.location, moduleName },
                })
                invalid = true
              }
            }
            if (invalid) return 'illegal'
            return 'statement'
          }
          case 'subscript': {
            const { index, value } = instruction
            const type = dfs(value)
            if (type === 'illegal') return 'illegal'
            if (type === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...value.location, moduleName },
              })
              return 'illegal'
            }
            if (Array.isArray(type)) {
              const indexType = dfs(index)
              if (indexType === 'illegal') return 'illegal'
              const lengthInt = BigInt(type.length)

              if (index.type !== 'literal' || index.valueType !== 'number') {
                errors.push({
                  type: 'index must be a number literal',
                  location: { ...index.location, moduleName },
                })
                return 'illegal'
              }

              const indexInt = BigInt(index.raw)
              if (indexInt >= lengthInt || indexInt < 0n) {
                errors.push({
                  type: 'index out of bounds',
                  location: { ...index.location, moduleName },
                })
                return 'illegal'
              }
              const returnedType = type[Number(index.raw)]
              return returnedType
            }

            if (type === 'address' && blockchain) {
              const indexType = dfs(index)
              if (indexType === 'illegal') return 'illegal'
              if (indexType !== 'int64') {
                errors.push({
                  type: 'instruction expects int64',
                  location: { ...index.location, moduleName },
                })
              }
              return 'int8'
            }

            errors.push({
              type: blockchain
                ? 'instruction expects address or tuple'
                : 'instruction expects tuple',
              location: { ...instruction.location, moduleName },
            })
            return 'illegal'
          }
          case 'unaryOp': {
            const { operator, value } = instruction
            const valueType = dfs(value)
            if (valueType === 'illegal') return 'illegal'
            if (valueType === 'statement') {
              errors.push({
                type: 'expression no statement',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (isNumeric(valueType)) {
              switch (operator) {
                case 'bitwise not':
                case 'minus':
                case 'plus':
                  return valueType
                case 'boolean not': {
                  errors.push({
                    type: 'unary operator expects numeric',
                    location: { ...instruction.location, moduleName },
                  })
                  return 'illegal'
                }
              }
            }
            if (Array.isArray(valueType)) {
              errors.push({
                type: "unary operator can't operate on tuples",
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (valueType === 'string') {
              errors.push({
                type: "unary operator can't operate on strings",
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (valueType === 'address') {
              errors.push({
                type: "unary operator can't operate on addresses",
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            if (valueType === 'bool') {
              switch (operator) {
                case 'bitwise not':
                case 'minus':
                case 'plus': {
                  errors.push({
                    type: 'unary operator expects boolean',
                    location: { ...instruction.location, moduleName },
                  })
                  return 'illegal'
                }
                case 'boolean not':
                  return 'bool'
              }
            }
            return consumeNever(valueType)
          }
          case 'get sender': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'address'
          }
          case 'communication area size': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'int64'
          }
          case 'get money': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            return 'int256'
          }
          case 'construct address': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            let invalid = false
            for (const byte of instruction.bytes) {
              const type = dfs(byte)
              if (type === 'illegal') invalid = true
              else if (type !== 'int8') {
                invalid = true
                errors.push({
                  type: 'instruction expects int8',
                  location: { ...byte.location, moduleName },
                })
              }
            }
            if (invalid) return 'illegal'
            return 'address'
          }
          case 'donate': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            let invalid = false
            const { money, address } = instruction
            const moneyType = dfs(money)
            const addressType = dfs(address)
            if (moneyType === 'illegal') invalid = true
            else if (moneyType !== 'int256') {
              invalid = true
              errors.push({
                type: 'instruction expects int256',
                location: { ...money.location, moduleName },
              })
            }
            if (addressType === 'illegal') invalid = true
            else if (addressType !== 'address') {
              invalid = true
              errors.push({
                type: 'instruction expects address',
                location: { ...address.location, moduleName },
              })
            }
            if (invalid) return 'illegal'
            return 'statement'
          }
          case 'invoke': {
            if (!blockchain) {
              errors.push({
                type: 'instruction only available in blockchain environment',
                location: { ...instruction.location, moduleName },
              })
              return 'illegal'
            }
            let invalid = false
            const { money, address, array, communicationSize } = instruction
            const moneyType = dfs(money)
            const addressType = dfs(address)
            const communicationSizeType = dfs(communicationSize)
            if (moneyType === 'illegal') invalid = true
            else if (moneyType !== 'int256') {
              invalid = true
              errors.push({
                type: 'instruction expects int256',
                location: { ...money.location, moduleName },
              })
            }
            if (addressType === 'illegal') invalid = true
            else if (addressType !== 'address') {
              invalid = true
              errors.push({
                type: 'instruction expects address',
                location: { ...address.location, moduleName },
              })
            }
            if (communicationSizeType === 'illegal') invalid = true
            else if (communicationSizeType !== 'int64') {
              invalid = true
              errors.push({
                type: 'instruction expects int64',
                location: { ...communicationSize.location, moduleName },
              })
            }
            const environmentArray = environment?.arrays.get(array)
            if (environmentArray === undefined) {
              invalid = true
              errors.push({
                type: 'undefined array',
                location: { ...instruction.location, moduleName },
              })
            } else {
              if (
                environmentArray.itemTypes.length !== 1 ||
                environmentArray.itemTypes[0] !== 'int8'
              ) {
                invalid = true
                errors.push({
                  type: 'instruction expects [int8] array',
                  location: { ...instruction.location, moduleName },
                })
              }
            }
            if (invalid) return 'illegal'
            return 'statement'
          }
        }
      }
      procedure.body.forEach(dfs)
      procedureMap.set(procedure.name, procedure)
      crossModuleProcedureMap.set([moduleName, procedure.name], procedure)
    }
  }
  return errors
}

